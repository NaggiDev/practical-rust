{
  "concepts": {
    "table-of-contents": {
      "title": "Table of Contents",
      "level": "intermediate",
      "description": "1. [Threading and Concurrency](#threading-and-concurrency)",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "table-of-contents",
      "keywords": [
        "arc",
        "mutex",
        "ownership",
        "rc",
        "thread",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "basic-level-conceptsbasic-level-concepts": {
      "title": "[Basic Level Concepts](#basic-level-concepts)",
      "level": "basic",
      "description": "1. [Variables and Mutability](#variables-and-mutability)",
      "file_path": "CONCEPTS.md",
      "section": "basic-level-conceptsbasic-level-concepts",
      "keywords": [
        "borrowing",
        "collect",
        "enum",
        "match",
        "option",
        "ownership",
        "reference",
        "result",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "intermediate-level-conceptsintermediate-level-concepts": {
      "title": "[Intermediate Level Concepts](#intermediate-level-concepts)",
      "level": "basic",
      "description": "1. [Advanced Ownership](#advanced-ownership)",
      "file_path": "CONCEPTS.md",
      "section": "intermediate-level-conceptsintermediate-level-concepts",
      "keywords": [
        "closure",
        "collect",
        "generic",
        "iterator",
        "lifetime",
        "ownership",
        "trait"
      ],
      "related_concepts": [],
      "projects": []
    },
    "advanced-level-conceptsadvanced-level-concepts": {
      "title": "[Advanced Level Concepts](#advanced-level-concepts)",
      "level": "basic",
      "description": "1. [Concurrency and Threading](#concurrency-and-threading)",
      "file_path": "CONCEPTS.md",
      "section": "advanced-level-conceptsadvanced-level-concepts",
      "keywords": [
        "macro",
        "thread",
        "trait",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": []
    },
    "expert-level-conceptsexpert-level-concepts": {
      "title": "[Expert Level Concepts](#expert-level-concepts)",
      "level": "basic",
      "description": "1. [Async Programming](#async-programming)",
      "file_path": "CONCEPTS.md",
      "section": "expert-level-conceptsexpert-level-concepts",
      "keywords": [
        "async"
      ],
      "related_concepts": [],
      "projects": []
    },
    "basic-level-concepts": {
      "title": "Basic Level Concepts",
      "level": "basic",
      "description": "No description available.",
      "file_path": "CONCEPTS.md",
      "section": "basic-level-concepts",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "variables-and-mutability": {
      "title": "Variables and Mutability",
      "level": "basic",
      "description": "Variables in Rust are immutable by default, which helps prevent bugs and makes code more predictable.",
      "file_path": "CONCEPTS.md",
      "section": "variables-and-mutability",
      "keywords": [
        "immutable",
        "mutable"
      ],
      "related_concepts": [],
      "projects": []
    },
    "immutable-variables": {
      "title": "Immutable Variables",
      "level": "basic",
      "description": "println!(\"The value of x is: {}\", x);",
      "file_path": "CONCEPTS.md",
      "section": "immutable-variables",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "mutable-variables": {
      "title": "Mutable Variables",
      "level": "basic",
      "description": "println!(\"The value of x is: {}\", x);",
      "file_path": "CONCEPTS.md",
      "section": "mutable-variables",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "constants": {
      "title": "Constants",
      "level": "basic",
      "description": "const THREE_HOURS_IN_SECONDS: u32 = 60  60  3;",
      "file_path": "CONCEPTS.md",
      "section": "constants",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "shadowing": {
      "title": "Shadowing",
      "level": "basic",
      "description": "let x = x + 1; // Shadowing the previous x",
      "file_path": "CONCEPTS.md",
      "section": "shadowing",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "data-types": {
      "title": "Data Types",
      "level": "basic",
      "description": "Rust is a statically typed language, meaning it must know the types of all variables at compile time.",
      "file_path": "CONCEPTS.md",
      "section": "data-types",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "scalar-types": {
      "title": "Scalar Types",
      "level": "basic",
      "description": "let decimal = 98_222;",
      "file_path": "CONCEPTS.md",
      "section": "scalar-types",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "compound-types": {
      "title": "Compound Types",
      "level": "basic",
      "description": "let tup: (i32, f64, u8) = (500, 6.4, 1);",
      "file_path": "CONCEPTS.md",
      "section": "compound-types",
      "keywords": [
        "arc",
        "rc",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "functions": {
      "title": "Functions",
      "level": "basic",
      "description": "Functions are defined using the fn keyword and follow snake_case naming convention.",
      "file_path": "CONCEPTS.md",
      "section": "functions",
      "keywords": [
        "fn"
      ],
      "related_concepts": [],
      "projects": []
    },
    "basic-function-definition": {
      "title": "Basic Function Definition",
      "level": "basic",
      "description": "println!(\"Hello, world!\");",
      "file_path": "CONCEPTS.md",
      "section": "basic-function-definition",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "functions-with-return-values": {
      "title": "Functions with Return Values",
      "level": "basic",
      "description": "5 // No semicolon - this is an expression",
      "file_path": "CONCEPTS.md",
      "section": "functions-with-return-values",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "statements-vs-expressions": {
      "title": "Statements vs Expressions",
      "level": "basic",
      "description": "x + 1 // Expression - no semicolon",
      "file_path": "CONCEPTS.md",
      "section": "statements-vs-expressions",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "control-flow": {
      "title": "Control Flow",
      "level": "basic",
      "description": "Control flow constructs allow you to control the execution path of your program.",
      "file_path": "CONCEPTS.md",
      "section": "control-flow",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "if-expressions": {
      "title": "if Expressions",
      "level": "basic",
      "description": "println!(\"condition was true\");",
      "file_path": "CONCEPTS.md",
      "section": "if-expressions",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "loops": {
      "title": "Loops",
      "level": "basic",
      "description": "// loop - infinite loop",
      "file_path": "CONCEPTS.md",
      "section": "loops",
      "keywords": [
        "result"
      ],
      "related_concepts": [],
      "projects": []
    },
    "ownership-basics": {
      "title": "Ownership Basics",
      "level": "basic",
      "description": "Ownership is Rust's most unique feature, enabling memory safety without garbage collection.",
      "file_path": "CONCEPTS.md",
      "section": "ownership-basics",
      "keywords": [
        "collect",
        "ownership"
      ],
      "related_concepts": [],
      "projects": []
    },
    "ownership-rules": {
      "title": "Ownership Rules",
      "level": "basic",
      "description": "1. Each value in Rust has an owner",
      "file_path": "CONCEPTS.md",
      "section": "ownership-rules",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "move-semantics": {
      "title": "Move Semantics",
      "level": "basic",
      "description": "let s1 = String::from(\"hello\");",
      "file_path": "CONCEPTS.md",
      "section": "move-semantics",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "copy-trait": {
      "title": "Copy Trait",
      "level": "basic",
      "description": "let y = x; // Copy, not move (integers implement Copy)",
      "file_path": "CONCEPTS.md",
      "section": "copy-trait",
      "keywords": [
        "impl",
        "ownership"
      ],
      "related_concepts": [],
      "projects": []
    },
    "references-and-borrowing": {
      "title": "References and Borrowing",
      "level": "basic",
      "description": "References allow you to use a value without taking ownership of it.",
      "file_path": "CONCEPTS.md",
      "section": "references-and-borrowing",
      "keywords": [
        "ownership",
        "reference"
      ],
      "related_concepts": [],
      "projects": []
    },
    "immutable-references": {
      "title": "Immutable References",
      "level": "basic",
      "description": "let s1 = String::from(\"hello\");",
      "file_path": "CONCEPTS.md",
      "section": "immutable-references",
      "keywords": [
        "ownership",
        "reference",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "mutable-references": {
      "title": "Mutable References",
      "level": "basic",
      "description": "let mut s = String::from(\"hello\");",
      "file_path": "CONCEPTS.md",
      "section": "mutable-references",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "reference-rules": {
      "title": "Reference Rules",
      "level": "basic",
      "description": "let mut s = String::from(\"hello\");",
      "file_path": "CONCEPTS.md",
      "section": "reference-rules",
      "keywords": [
        "borrowing",
        "immutable",
        "mutable",
        "reference",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "structs": {
      "title": "Structs",
      "level": "basic",
      "description": "Structs let you create custom data types that group related data together.",
      "file_path": "CONCEPTS.md",
      "section": "structs",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "defining-and-instantiating-structs": {
      "title": "Defining and Instantiating Structs",
      "level": "basic",
      "description": "email: String::from(\"someone@example.com\"),",
      "file_path": "CONCEPTS.md",
      "section": "defining-and-instantiating-structs",
      "keywords": [
        "mutable",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "tuple-structs": {
      "title": "Tuple Structs",
      "level": "basic",
      "description": "struct Color(i32, i32, i32);",
      "file_path": "CONCEPTS.md",
      "section": "tuple-structs",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "unit-like-structs": {
      "title": "Unit-Like Structs",
      "level": "basic",
      "description": "let subject = AlwaysEqual;",
      "file_path": "CONCEPTS.md",
      "section": "unit-like-structs",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "methods": {
      "title": "Methods",
      "level": "basic",
      "description": "fn area(&self) -> u32 {",
      "file_path": "CONCEPTS.md",
      "section": "methods",
      "keywords": [
        "impl",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "enums": {
      "title": "Enums",
      "level": "basic",
      "description": "Enums in Rust are a way to define a type that can be one of several variants:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "enums",
      "keywords": [
        "enum"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "defining-enums": {
      "title": "Defining Enums",
      "level": "basic",
      "description": "Move { x: i32, y: i32 },",
      "file_path": "CONCEPTS.md",
      "section": "defining-enums",
      "keywords": [
        "enum",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "methods-on-enums": {
      "title": "Methods on Enums",
      "level": "basic",
      "description": "// method body would be defined here",
      "file_path": "CONCEPTS.md",
      "section": "methods-on-enums",
      "keywords": [
        "impl",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "the-option-enum": {
      "title": "The Option Enum",
      "level": "basic",
      "description": "let some_number = Some(5);",
      "file_path": "CONCEPTS.md",
      "section": "the-option-enum",
      "keywords": [
        "enum",
        "match",
        "option"
      ],
      "related_concepts": [],
      "projects": []
    },
    "pattern-matching": {
      "title": "Pattern Matching",
      "level": "basic",
      "description": "The match expression allows you to compare a value against a series of patterns:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "pattern-matching",
      "keywords": [
        "match"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "basic-match": {
      "title": "Basic Match",
      "level": "basic",
      "description": "fn value_in_cents(coin: Coin) -> u8 {",
      "file_path": "CONCEPTS.md",
      "section": "basic-match",
      "keywords": [
        "enum",
        "match"
      ],
      "related_concepts": [],
      "projects": []
    },
    "patterns-that-bind-to-values": {
      "title": "Patterns that Bind to Values",
      "level": "basic",
      "description": "fn value_in_cents(coin: Coin) -> u8 {",
      "file_path": "CONCEPTS.md",
      "section": "patterns-that-bind-to-values",
      "keywords": [
        "enum",
        "match"
      ],
      "related_concepts": [],
      "projects": []
    },
    "matching-with-optiont": {
      "title": "Matching with Option<T>",
      "level": "basic",
      "description": "fn plus_one(x: Option<i32>) -> Option<i32> {",
      "file_path": "CONCEPTS.md",
      "section": "matching-with-optiont",
      "keywords": [
        "match",
        "option"
      ],
      "related_concepts": [],
      "projects": []
    },
    "catch-all-patterns": {
      "title": "Catch-all Patterns",
      "level": "basic",
      "description": "3 => add_fancy_hat(),",
      "file_path": "CONCEPTS.md",
      "section": "catch-all-patterns",
      "keywords": [
        "match"
      ],
      "related_concepts": [],
      "projects": []
    },
    "if-let": {
      "title": "if let",
      "level": "basic",
      "description": "let config_max = Some(3u8);",
      "file_path": "CONCEPTS.md",
      "section": "if-let",
      "keywords": [
        "match"
      ],
      "related_concepts": [],
      "projects": []
    },
    "error-handling-with-result-and-option": {
      "title": "Error Handling with Result and Option",
      "level": "basic",
      "description": "Rust groups errors into two major categories: recoverable and unrecoverable errors.",
      "file_path": "CONCEPTS.md",
      "section": "error-handling-with-result-and-option",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "resultt-e": {
      "title": "Result<T, E>",
      "level": "basic",
      "description": "use std::io::ErrorKind;",
      "file_path": "CONCEPTS.md",
      "section": "resultt-e",
      "keywords": [
        "match",
        "result"
      ],
      "related_concepts": [],
      "projects": []
    },
    "shortcuts-for-panic-on-error": {
      "title": "Shortcuts for Panic on Error",
      "level": "basic",
      "description": "// unwrap() panics if Result is Err",
      "file_path": "CONCEPTS.md",
      "section": "shortcuts-for-panic-on-error",
      "keywords": [
        "expect",
        "result",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": []
    },
    "propagating-errors": {
      "title": "Propagating Errors",
      "level": "expert",
      "description": "Errors in async code are handled similarly to sync code, but with await:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "propagating-errors",
      "keywords": [
        "async",
        "await",
        "result",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "collections": {
      "title": "Collections",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "collections",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "vectors": {
      "title": "Vectors",
      "level": "basic",
      "description": "Our TaskList uses a vector to store tasks:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "vectors",
      "keywords": [
        "rust\ntasks: vec<task>,\n",
        "tasklist",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "hash-maps": {
      "title": "Hash Maps",
      "level": "basic",
      "description": "use std::collections::HashMap;",
      "file_path": "CONCEPTS.md",
      "section": "hash-maps",
      "keywords": [
        "collect",
        "map",
        "string",
        "unwrap",
        "vec"
      ],
      "related_concepts": [],
      "projects": []
    },
    "string-handling": {
      "title": "String Handling",
      "level": "advanced",
      "description": "C strings are null-terminated, while Rust strings are UTF-8 with length:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "string-handling",
      "keywords": [
        "string",
        "unsafe",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "creating-strings": {
      "title": "Creating Strings",
      "level": "basic",
      "description": "// Different ways to create strings",
      "file_path": "CONCEPTS.md",
      "section": "creating-strings",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "updating-strings": {
      "title": "Updating Strings",
      "level": "basic",
      "description": "let mut s = String::from(\"foo\");",
      "file_path": "CONCEPTS.md",
      "section": "updating-strings",
      "keywords": [
        "macro",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "string-slices": {
      "title": "String Slices",
      "level": "basic",
      "description": "let s = String::from(\"hello world\");",
      "file_path": "CONCEPTS.md",
      "section": "string-slices",
      "keywords": [
        "enum",
        "slice",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "iterating-over-strings": {
      "title": "Iterating Over Strings",
      "level": "basic",
      "description": "for c in \"ะะด\".chars() {",
      "file_path": "CONCEPTS.md",
      "section": "iterating-over-strings",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "intermediate-level-concepts": {
      "title": "Intermediate Level Concepts",
      "level": "basic",
      "description": "No description available.",
      "file_path": "CONCEPTS.md",
      "section": "intermediate-level-concepts",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "advanced-ownership": {
      "title": "Advanced Ownership",
      "level": "basic",
      "description": "Building on basic ownership concepts, advanced ownership covers more complex scenarios.",
      "file_path": "CONCEPTS.md",
      "section": "advanced-ownership",
      "keywords": [
        "ownership"
      ],
      "related_concepts": [],
      "projects": []
    },
    "lifetimes-in-function-signatures": {
      "title": "Lifetimes in Function Signatures",
      "level": "basic",
      "description": "fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {",
      "file_path": "CONCEPTS.md",
      "section": "lifetimes-in-function-signatures",
      "keywords": [
        "result",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "lifetime-annotations-in-struct-definitions": {
      "title": "Lifetime Annotations in Struct Definitions",
      "level": "basic",
      "description": "struct ImportantExcerpt<'a> {",
      "file_path": "CONCEPTS.md",
      "section": "lifetime-annotations-in-struct-definitions",
      "keywords": [
        "expect",
        "impl",
        "lifetime",
        "reference",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "lifetimes": {
      "title": "Lifetimes",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "lifetimes",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "lifetime-elision-rules": {
      "title": "Lifetime Elision Rules",
      "level": "basic",
      "description": "// These functions don't need explicit lifetime annotations",
      "file_path": "CONCEPTS.md",
      "section": "lifetime-elision-rules",
      "keywords": [
        "enum",
        "lifetime"
      ],
      "related_concepts": [],
      "projects": []
    },
    "static-lifetime": {
      "title": "Static Lifetime",
      "level": "basic",
      "description": "let s: &'static str = \"I have a static lifetime.\";",
      "file_path": "CONCEPTS.md",
      "section": "static-lifetime",
      "keywords": [
        "lifetime",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "traits": {
      "title": "Traits",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "traits",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "defining-traits": {
      "title": "Defining Traits",
      "level": "basic",
      "description": "fn summarize(&self) -> String;",
      "file_path": "CONCEPTS.md",
      "section": "defining-traits",
      "keywords": [
        "impl",
        "string",
        "struct",
        "trait"
      ],
      "related_concepts": [],
      "projects": []
    },
    "traits-as-parameters": {
      "title": "Traits as Parameters",
      "level": "basic",
      "description": "pub fn notify(item: &impl Summary) {",
      "file_path": "CONCEPTS.md",
      "section": "traits-as-parameters",
      "keywords": [
        "impl",
        "trait"
      ],
      "related_concepts": [],
      "projects": []
    },
    "returning-types-that-implement-traits": {
      "title": "Returning Types that Implement Traits",
      "level": "basic",
      "description": "fn returns_summarizable() -> impl Summary {",
      "file_path": "CONCEPTS.md",
      "section": "returning-types-that-implement-traits",
      "keywords": [
        "impl",
        "string",
        "trait"
      ],
      "related_concepts": [],
      "projects": []
    },
    "generics": {
      "title": "Generics",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "generics",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "generic-functions": {
      "title": "Generic Functions",
      "level": "intermediate",
      "description": "fn process_collection<T, C>(collection: C)",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "generic-functions",
      "keywords": [
        "collect",
        "generic",
        "iterator",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "generic-structs": {
      "title": "Generic Structs",
      "level": "basic",
      "description": "// Implementation for specific type",
      "file_path": "CONCEPTS.md",
      "section": "generic-structs",
      "keywords": [
        "generic",
        "impl",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "generic-enums": {
      "title": "Generic Enums",
      "level": "basic",
      "description": "Official Documentation: [Generic Types, Traits, and Lifetimes](https://doc.rust-lang.org/book/ch10-00-generics.html)",
      "file_path": "CONCEPTS.md",
      "section": "generic-enums",
      "keywords": [
        "enum",
        "generic",
        "lifetime",
        "option",
        "result",
        "trait"
      ],
      "related_concepts": [],
      "projects": []
    },
    "foreign-function-interface-ffi": {
      "title": "Foreign Function Interface (FFI)",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "foreign-function-interface-ffi",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "what-is-ffi": {
      "title": "What is FFI?",
      "level": "advanced",
      "description": "Foreign Function Interface (FFI) is a mechanism that allows code written in one programming language to call functions written in another language. In Rust's case, FFI primarily refers to calling C fu...",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "what-is-ffi",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "why-use-ffi": {
      "title": "Why Use FFI?",
      "level": "advanced",
      "description": "1. Legacy Integration: Use existing C libraries without rewriting them",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "why-use-ffi",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "basic-ffi-declaration": {
      "title": "Basic FFI Declaration",
      "level": "advanced",
      "description": "fn add_numbers(a: i32, b: i32) -> i32;",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "basic-ffi-declaration",
      "keywords": [
        "\n\nthe "
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "c-abi-compatibility": {
      "title": "C ABI Compatibility",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "c-abi-compatibility",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "application-binary-interface-abi": {
      "title": "Application Binary Interface (ABI)",
      "level": "advanced",
      "description": "The ABI defines how functions are called at the binary level, including:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "application-binary-interface-abi",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "c-calling-convention": {
      "title": "C Calling Convention",
      "level": "advanced",
      "description": "Rust uses extern \"C\" to specify the C calling convention:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "c-calling-convention",
      "keywords": [
        "extern \"c\""
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "data-layout-compatibility": {
      "title": "Data Layout Compatibility",
      "level": "advanced",
      "description": "Rust types must match C types in memory layout:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "data-layout-compatibility",
      "keywords": [
        "match"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "memory-management-across-language-boundaries": {
      "title": "Memory Management Across Language Boundaries",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "memory-management-across-language-boundaries",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "the-challenge": {
      "title": "The Challenge",
      "level": "advanced",
      "description": "Rust's ownership system doesn't extend across FFI boundaries. When calling C functions:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "the-challenge",
      "keywords": [
        "ownership"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "memory-allocation-patterns": {
      "title": "Memory Allocation Patterns",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "memory-allocation-patterns",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "1-rust-allocates-c-uses": {
      "title": "1. Rust Allocates, C Uses",
      "level": "advanced",
      "description": "let data = vec![1, 2, 3, 4, 5];",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "1-rust-allocates-c-uses",
      "keywords": [
        "unsafe",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "2-c-allocates-rust-uses": {
      "title": "2. C Allocates, Rust Uses",
      "level": "advanced",
      "description": "let ptr = allocate_string(100);",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "2-c-allocates-rust-uses",
      "keywords": [
        "string",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "3-safe-wrapper-pattern": {
      "title": "3. Safe Wrapper Pattern",
      "level": "advanced",
      "description": "pub struct CAllocatedString {",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "3-safe-wrapper-pattern",
      "keywords": [
        "impl",
        "string",
        "struct",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "type-conversion-between-rust-and-c": {
      "title": "Type Conversion Between Rust and C",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "type-conversion-between-rust-and-c",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "primitive-types": {
      "title": "Primitive Types",
      "level": "basic",
      "description": "The calculator uses several primitive types:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "primitive-types",
      "keywords": [
        "&str",
        "f64",
        "slice",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "pointer-types": {
      "title": "Pointer Types",
      "level": "advanced",
      "description": "const T    // const T in C (read-only)",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "pointer-types",
      "keywords": [
        "mutable"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "array-handling": {
      "title": "Array Handling",
      "level": "advanced",
      "description": "// Passing Rust slice to C",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "array-handling",
      "keywords": [
        "slice",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "complex-types": {
      "title": "Complex Types",
      "level": "advanced",
      "description": "For complex types, you often need to define C-compatible representations:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "complex-types",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "error-handling-in-ffi": {
      "title": "Error Handling in FFI",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "error-handling-in-ffi",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "c-error-conventions": {
      "title": "C Error Conventions",
      "level": "advanced",
      "description": "C libraries typically use several error reporting mechanisms:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "c-error-conventions",
      "keywords": [
        "errno"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "rust-error-handling": {
      "title": "Rust Error Handling",
      "level": "advanced",
      "description": "Convert C errors to Rust's Result type:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "rust-error-handling",
      "keywords": [
        "result",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "error-propagation": {
      "title": "Error Propagation",
      "level": "basic",
      "description": "The ? operator is used to propagate errors up the call stack:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "error-propagation",
      "keywords": [
        "?",
        "result",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "safety-considerations": {
      "title": "Safety Considerations",
      "level": "advanced",
      "description": "- Raw pointers can be null",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "safety-considerations",
      "keywords": [
        "lifetime"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "unsafe-code-requirements": {
      "title": "Unsafe Code Requirements",
      "level": "advanced",
      "description": "FFI operations are inherently unsafe because:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "unsafe-code-requirements",
      "keywords": [
        "rc",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "safety-guidelines": {
      "title": "Safety Guidelines",
      "level": "advanced",
      "description": "1. Minimize unsafe code: Keep unsafe blocks as small as possible",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "safety-guidelines",
      "keywords": [
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "safe-wrapper-pattern": {
      "title": "Safe Wrapper Pattern",
      "level": "advanced",
      "description": "pub fn safe_wrapper(input: &str) -> Result<String, FfiError> {",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "safe-wrapper-pattern",
      "keywords": [
        "result",
        "string",
        "unsafe",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "build-system-integration": {
      "title": "Build System Integration",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "build-system-integration",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "using-cc-crate": {
      "title": "Using cc Crate",
      "level": "advanced",
      "description": "The cc crate allows compiling C code as part of the Rust build:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "using-cc-crate",
      "keywords": [
        "cc"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "linking-libraries": {
      "title": "Linking Libraries",
      "level": "advanced",
      "description": "// Link static library",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "linking-libraries",
      "keywords": [
        "arc",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "build-dependencies": {
      "title": "Build Dependencies",
      "level": "advanced",
      "description": "cc = \"1.0\"          # For compiling C code",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "build-dependencies",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "automatic-binding-generation": {
      "title": "Automatic Binding Generation",
      "level": "advanced",
      "description": "Using bindgen to automatically generate Rust bindings:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "automatic-binding-generation",
      "keywords": [
        "bindgen",
        "box",
        "expect"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "advanced-ffi-patterns": {
      "title": "Advanced FFI Patterns",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "advanced-ffi-patterns",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "callbacks": {
      "title": "Callbacks",
      "level": "advanced",
      "description": "Allowing C code to call back into Rust:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "callbacks",
      "keywords": [
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "complex-data-structures": {
      "title": "Complex Data Structures",
      "level": "advanced",
      "description": "struct ComplexStruct {",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "complex-data-structures",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "thread-safety": {
      "title": "Thread Safety",
      "level": "advanced",
      "description": "Making allocators thread-safe requires careful synchronization.",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "thread-safety",
      "keywords": [
        "thread"
      ],
      "related_concepts": [
        "careful-synchronization"
      ],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "dynamic-loading": {
      "title": "Dynamic Loading",
      "level": "advanced",
      "description": "Loading libraries at runtime:",
      "file_path": "advanced\\c-library-binding\\CONCEPTS.md",
      "section": "dynamic-loading",
      "keywords": [
        "result",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "c-library-binding"
      ]
    },
    "best-practices": {
      "title": "Best Practices",
      "level": "intermediate",
      "description": "1. Use Trait Bounds: Constrain generics appropriately",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "best-practices",
      "keywords": [
        "collect",
        "generic",
        "impl",
        "trait",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "common-pitfalls": {
      "title": "Common pitfalls",
      "level": "intermediate",
      "description": "- Not understanding the performance characteristics of different collections",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "common-pitfalls",
      "keywords": [
        "arc",
        "collect",
        "ownership",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "conclusion": {
      "title": "Conclusion",
      "level": "expert",
      "description": "Compiler plugins represent a powerful way to extend Rust's capabilities. By understanding the concepts covered in this document, you can create tools that help developers write better, more maintainab...",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "conclusion",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "concurrency-and-thread-management": {
      "title": "Concurrency and Thread Management",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "concurrency-and-thread-management",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "work-stealing-thread-pool": {
      "title": "Work-Stealing Thread Pool",
      "level": "advanced",
      "description": "The project implements a sophisticated work-stealing thread pool that demonstrates several advanced concurrency concepts:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "work-stealing-thread-pool",
      "keywords": [
        "impl",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "key-components": {
      "title": "Key Components:",
      "level": "advanced",
      "description": "1. Per-Worker Queues: Each worker thread has its own lock-free queue",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "key-components",
      "keywords": [
        "arc",
        "crossbeam::deque",
        "rc",
        "struct",
        "thread",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "concepts-demonstrated": {
      "title": "Concepts Demonstrated:",
      "level": "advanced",
      "description": "- Lock-Free Programming: Using atomic operations and lock-free queues",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "concepts-demonstrated",
      "keywords": [
        "rc",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "synchronization-primitives": {
      "title": "Synchronization Primitives",
      "level": "advanced",
      "description": "Mutex: Mutual exclusion lock:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "synchronization-primitives",
      "keywords": [
        "impl",
        "mutex",
        "struct",
        "thread",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "unsafe-rust-and-memory-management": {
      "title": "Unsafe Rust and Memory Management",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "unsafe-rust-and-memory-management",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "custom-memory-allocators": {
      "title": "Custom Memory Allocators",
      "level": "advanced",
      "description": "The project implements two types of custom allocators:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "custom-memory-allocators",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "bump-allocator": {
      "title": "Bump Allocator",
      "level": "advanced",
      "description": "- Very fast allocation (just increment a pointer)",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "bump-allocator",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "free-list-allocator": {
      "title": "Free List Allocator",
      "level": "advanced",
      "description": "- Supports individual deallocation",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "free-list-allocator",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "safety-invariants": {
      "title": "Safety Invariants",
      "level": "advanced",
      "description": "The unsafe code maintains several safety invariants:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "safety-invariants",
      "keywords": [
        "lifetime",
        "thread",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "c-library-integration": {
      "title": "C Library Integration",
      "level": "advanced",
      "description": "The project integrates with a C library for performance-critical operations:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "c-library-integration",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "c-library-functions": {
      "title": "C Library Functions:",
      "level": "advanced",
      "description": "- Mathematical operations (factorial, fibonacci, sqrt, gcd)",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "c-library-functions",
      "keywords": [
        "rc",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "safe-rust-wrappers": {
      "title": "Safe Rust Wrappers:",
      "level": "advanced",
      "description": "pub fn execute_math_operation(op: MathOperation, args: &[i64]) -> Result<i64> {",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "safe-rust-wrappers",
      "keywords": [
        "match",
        "rc",
        "result",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "ffi-safety-patterns": {
      "title": "FFI Safety Patterns",
      "level": "advanced",
      "description": "1. Input Validation: Checking parameters before passing to C",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "ffi-safety-patterns",
      "keywords": [
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "macros-and-domain-specific-languages": {
      "title": "Macros and Domain-Specific Languages",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "macros-and-domain-specific-languages",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "declarative-macros": {
      "title": "Declarative Macros",
      "level": "advanced",
      "description": "Declarative macros use pattern matching to transform code. They're defined with macro_rules! and use a syntax similar to match expressions.",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "declarative-macros",
      "keywords": [
        "macro",
        "macro_rules!",
        "match"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "configuration-dsl": {
      "title": "Configuration DSL",
      "level": "advanced",
      "description": "The project includes a comprehensive configuration system:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "configuration-dsl",
      "keywords": [
        "option"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "advanced-traits-and-type-system": {
      "title": "Advanced Traits and Type System",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "advanced-traits-and-type-system",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "trait-hierarchies": {
      "title": "Trait Hierarchies",
      "level": "advanced",
      "description": "The project defines sophisticated trait hierarchies:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "trait-hierarchies",
      "keywords": [
        "arc",
        "async",
        "box",
        "generic",
        "rc",
        "result",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "generic-programming": {
      "title": "Generic Programming",
      "level": "advanced",
      "description": "The project extensively uses generics for flexibility:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "generic-programming",
      "keywords": [
        "generic",
        "impl",
        "lifetime",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "error-handling-patterns": {
      "title": "Error Handling Patterns",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "error-handling-patterns",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "comprehensive-error-types": {
      "title": "Comprehensive Error Types",
      "level": "advanced",
      "description": "The project defines a comprehensive error hierarchy:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "comprehensive-error-types",
      "keywords": [
        "arc",
        "enum",
        "rc",
        "string",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "error-recovery": {
      "title": "Error Recovery",
      "level": "expert",
      "description": "Implement retry logic for transient failures:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "error-recovery",
      "keywords": [
        "async",
        "await",
        "box",
        "impl",
        "match",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "integration-and-architecture": {
      "title": "Integration and Architecture",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "integration-and-architecture",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "component-integration": {
      "title": "Component Integration",
      "level": "advanced",
      "description": "The capstone project demonstrates how to integrate multiple advanced concepts:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "component-integration",
      "keywords": [
        "arc",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "performance-considerations": {
      "title": "Performance Considerations",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "performance-considerations",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "testing-strategies": {
      "title": "Testing Strategies",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "testing-strategies",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "real-world-applications": {
      "title": "Real-World Applications",
      "level": "advanced",
      "description": "This capstone project demonstrates patterns used in:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "real-world-applications",
      "keywords": [
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "learning-outcomes": {
      "title": "Learning Outcomes",
      "level": "advanced",
      "description": "By completing this capstone project, you have demonstrated mastery of:",
      "file_path": "advanced\\capstone-project\\CONCEPTS.md",
      "section": "learning-outcomes",
      "keywords": [
        "arc",
        "generic",
        "macro",
        "rc",
        "trait",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "next-steps": {
      "title": "Next Steps",
      "level": "intermediate",
      "description": "After completing this project, you should be comfortable with:",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "next-steps",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "unsafe-rust": {
      "title": "Unsafe Rust",
      "level": "advanced",
      "description": "Unsafe Rust allows you to bypass Rust's safety guarantees when necessary. It's required for low-level operations like memory allocation.",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "unsafe-rust",
      "keywords": [
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "key-concepts": {
      "title": "Key Concepts",
      "level": "expert",
      "description": "- Token Streams: The raw representation of Rust code as a sequence of tokens",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "key-concepts",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "when-to-use-unsafe": {
      "title": "When to Use Unsafe",
      "level": "advanced",
      "description": "- Interfacing with C libraries (FFI)",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "when-to-use-unsafe",
      "keywords": [
        "impl",
        "struct",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "raw-pointers": {
      "title": "Raw Pointers",
      "level": "intermediate",
      "description": "The project uses raw pointers (*mut T) for manual memory management:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "raw-pointers",
      "keywords": [
        "*mut t",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "types-of-raw-pointers": {
      "title": "Types of Raw Pointers",
      "level": "advanced",
      "description": "Immutable Raw Pointers (*const T):",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "types-of-raw-pointers",
      "keywords": [
        "\n\n**mutable raw pointers** (",
        "):\n",
        "*const t",
        "immutable",
        "mutable"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "operations-on-raw-pointers": {
      "title": "Operations on Raw Pointers",
      "level": "advanced",
      "description": "Creating Raw Pointers:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "operations-on-raw-pointers",
      "keywords": [
        "\n\n**pointer arithmetic**:\n",
        "reference",
        "unsafe"
      ],
      "related_concepts": [
        "unsafe"
      ],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "memory-layout-and-alignment": {
      "title": "Memory Layout and Alignment",
      "level": "advanced",
      "description": "Understanding memory layout is crucial for implementing allocators correctly.",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "memory-layout-and-alignment",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "alignment-requirements": {
      "title": "Alignment Requirements",
      "level": "advanced",
      "description": "Different types have different alignment requirements:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "alignment-requirements",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "layout-struct": {
      "title": "Layout Struct",
      "level": "advanced",
      "description": "The Layout struct describes memory layout requirements:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "layout-struct",
      "keywords": [
        "layout",
        "struct",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "alignment-calculations": {
      "title": "Alignment Calculations",
      "level": "advanced",
      "description": "/// Align a value up to the nearest multiple of align",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "alignment-calculations",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "why-alignment-matters": {
      "title": "Why Alignment Matters",
      "level": "advanced",
      "description": "- Performance: Aligned access is faster on most architectures",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "why-alignment-matters",
      "keywords": [
        "arc",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "the-globalalloc-trait": {
      "title": "The GlobalAlloc Trait",
      "level": "advanced",
      "description": "The GlobalAlloc trait defines the interface for memory allocators in Rust.",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "the-globalalloc-trait",
      "keywords": [
        "globalalloc",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "trait-definition": {
      "title": "Trait Definition",
      "level": "advanced",
      "description": "pub unsafe trait GlobalAlloc {",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "trait-definition",
      "keywords": [
        "impl",
        "option",
        "trait",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "implementation-requirements": {
      "title": "Implementation Requirements",
      "level": "advanced",
      "description": "- Return a pointer to memory that satisfies the layout requirements",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "implementation-requirements",
      "keywords": [
        "alloc"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "safety-requirements": {
      "title": "Safety Requirements",
      "level": "advanced",
      "description": "- Allocated memory must be properly aligned",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "safety-requirements",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "memory-safety-invariants": {
      "title": "Memory Safety Invariants",
      "level": "advanced",
      "description": "Memory safety invariants are conditions that must always be true for safe operation.",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "memory-safety-invariants",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "common-invariants": {
      "title": "Common Invariants",
      "level": "advanced",
      "description": "Pointer Validity:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "common-invariants",
      "keywords": [
        "lifetime",
        "reference"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "documenting-invariants": {
      "title": "Documenting Invariants",
      "level": "advanced",
      "description": "/// A simple bump allocator",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "documenting-invariants",
      "keywords": [
        "\n/// - ",
        " is always <= ",
        "impl",
        "lifetime",
        "mutex",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "checking-invariants": {
      "title": "Checking Invariants",
      "level": "advanced",
      "description": "Use debug assertions to check invariants:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "checking-invariants",
      "keywords": [
        "unsafe",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "atomic-operations": {
      "title": "Atomic Operations",
      "level": "advanced",
      "description": "Atomic operations provide thread-safe access to shared data without locks.",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "atomic-operations",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "atomic-types": {
      "title": "Atomic Types",
      "level": "advanced",
      "description": "use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "atomic-types",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "memory-ordering": {
      "title": "Memory Ordering",
      "level": "advanced",
      "description": "Different ordering guarantees for atomic operations:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "memory-ordering",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "common-operations": {
      "title": "Common Operations",
      "level": "advanced",
      "description": "let value = counter.load(Ordering::Relaxed);",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "common-operations",
      "keywords": [
        "expect",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "send-and-sync-traits": {
      "title": "Send and Sync Traits",
      "level": "advanced",
      "description": "Send: Type can be transferred between threads:",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "send-and-sync-traits",
      "keywords": [
        "impl",
        "thread",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "thread-safety-considerations": {
      "title": "Thread Safety Considerations",
      "level": "advanced",
      "description": "- Minimize lock contention",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "thread-safety-considerations",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "memory-management-strategies": {
      "title": "Memory Management Strategies",
      "level": "advanced",
      "description": "Different allocation strategies have different trade-offs.",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "memory-management-strategies",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "pool-allocator": {
      "title": "Pool Allocator",
      "level": "advanced",
      "description": "- Very fast for fixed-size allocations",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "pool-allocator",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "slab-allocator": {
      "title": "Slab Allocator",
      "level": "advanced",
      "description": "- Optimized for specific object sizes",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "slab-allocator",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "safety-first": {
      "title": "Safety First",
      "level": "advanced",
      "description": "1. Document all unsafe code with safety requirements",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "safety-first",
      "keywords": [
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "debugging-unsafe-code": {
      "title": "Debugging Unsafe Code",
      "level": "advanced",
      "description": "1. Use Miri for detecting undefined behavior",
      "file_path": "advanced\\custom-memory-allocator\\CONCEPTS.md",
      "section": "debugging-unsafe-code",
      "keywords": [
        "impl",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-memory-allocator"
      ]
    },
    "further-reading": {
      "title": "Further Reading",
      "level": "intermediate",
      "description": "- [The Rust Book - Concurrency](https://doc.rust-lang.org/book/ch16-00-fearless-concurrency.html)",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "further-reading",
      "keywords": [
        "ownership",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "introduction-to-macros": {
      "title": "Introduction to Macros",
      "level": "advanced",
      "description": "Macros in Rust are a form of metaprogramming that allows you to write code that writes other code. They operate at compile time, transforming source code before it's compiled into machine code.",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "introduction-to-macros",
      "keywords": [
        "macro",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "why-use-macros": {
      "title": "Why Use Macros?",
      "level": "advanced",
      "description": "- Code Generation: Automatically generate repetitive code",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "why-use-macros",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "types-of-macros": {
      "title": "Types of Macros",
      "level": "advanced",
      "description": "Rust has two main types of macros:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "types-of-macros",
      "keywords": [
        "macro",
        "macro_rules!",
        "match"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "basic-syntax": {
      "title": "Basic Syntax",
      "level": "advanced",
      "description": "macro_rules! macro_name {",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "basic-syntax",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "token-types": {
      "title": "Token Types",
      "level": "expert",
      "description": "- Identifiers: Variable names, function names, etc.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "token-types",
      "keywords": [
        "fn",
        "impl",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "example-simple-configuration-macro": {
      "title": "Example: Simple Configuration Macro",
      "level": "advanced",
      "description": "macro_rules! simple_config {",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "example-simple-configuration-macro",
      "keywords": [
        "\n\n**explanation**:\n- ",
        " captures the struct name\n- ",
        "impl",
        "macro",
        "match",
        "option",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "recursive-macros": {
      "title": "Recursive Macros",
      "level": "advanced",
      "description": "Macros can call themselves recursively to handle complex nested structures:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "recursive-macros",
      "keywords": [
        "macro",
        "match",
        "result",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "procedural-macros": {
      "title": "Procedural Macros",
      "level": "expert",
      "description": "Procedural macros are Rust's mechanism for metaprogramming - code that generates code. Unlike declarative macros (macro_rules!), procedural macros are functions that take token streams as input and pr...",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "procedural-macros",
      "keywords": [
        "macro",
        "macro_rules!"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "types-of-procedural-macros": {
      "title": "Types of Procedural Macros",
      "level": "expert",
      "description": "1. Function-like macros (#[proc_macro])",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "types-of-procedural-macros",
      "keywords": [
        "#[proc_macro]",
        "#[proc_macro_attribute]",
        "#[proc_macro_derive]",
        "impl",
        "macro",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "setting-up-procedural-macros": {
      "title": "Setting Up Procedural Macros",
      "level": "advanced",
      "description": "To create procedural macros, you need:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "setting-up-procedural-macros",
      "keywords": [
        "cargo.toml",
        "macro",
        "proc-macro = true",
        "proc-macro2",
        "quote",
        "syn"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "derive-macros": {
      "title": "Derive Macros",
      "level": "advanced",
      "description": "Derive macros automatically implement traits for structs and enums:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "derive-macros",
      "keywords": [
        "\n\n**key components**:\n- ",
        "enum",
        "impl",
        "macro",
        "result",
        "string",
        "struct",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "attribute-macros": {
      "title": "Attribute Macros",
      "level": "advanced",
      "description": "Attribute macros can modify the items they're applied to:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "attribute-macros",
      "keywords": [
        "macro",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "function-like-macros": {
      "title": "Function-like Macros",
      "level": "advanced",
      "description": "Function-like procedural macros provide the most flexibility:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "function-like-macros",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "token-streams-and-parsing": {
      "title": "Token Streams and Parsing",
      "level": "advanced",
      "description": "Understanding token streams is crucial for working with procedural macros.",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "token-streams-and-parsing",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "token-streams": {
      "title": "Token Streams",
      "level": "expert",
      "description": "Token streams represent Rust code as a sequence of tokens. They're the interface between the compiler and procedural macros.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "token-streams",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "parsing-with-syn": {
      "title": "Parsing with `syn`",
      "level": "advanced",
      "description": "The syn crate provides tools for parsing Rust syntax:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "parsing-with-syn",
      "keywords": [
        "enum",
        "macro",
        "match",
        "struct",
        "syn",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "code-generation-with-quote": {
      "title": "Code Generation with `quote`",
      "level": "advanced",
      "description": "The quote crate provides a template system for generating code:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "code-generation-with-quote",
      "keywords": [
        "\n\n**template features**:\n- ",
        ": interpolate variables\n- ",
        "impl",
        "iterator",
        "quote",
        "struct",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "macro-hygiene": {
      "title": "Macro Hygiene",
      "level": "advanced",
      "description": "Macro hygiene prevents name collisions between macro-generated code and user code.",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "macro-hygiene",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "hygienic-macros": {
      "title": "Hygienic Macros",
      "level": "advanced",
      "description": "Rust macros are hygienic by default, meaning:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "hygienic-macros",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "example-of-hygiene": {
      "title": "Example of Hygiene",
      "level": "advanced",
      "description": "macro_rules! create_function {",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "example-of-hygiene",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "breaking-hygiene": {
      "title": "Breaking Hygiene",
      "level": "advanced",
      "description": "Sometimes you need to break hygiene intentionally:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "breaking-hygiene",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "error-handling-in-macros": {
      "title": "Error Handling in Macros",
      "level": "expert",
      "description": "pub fn derive_my_trait(input: TokenStream) -> TokenStream {",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "error-handling-in-macros",
      "keywords": [
        "impl",
        "macro",
        "match",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "compile-time-errors": {
      "title": "Compile-Time Errors",
      "level": "advanced",
      "description": "Macros can generate compile-time errors:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "compile-time-errors",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "procedural-macro-errors": {
      "title": "Procedural Macro Errors",
      "level": "advanced",
      "description": "Procedural macros can return detailed error information:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "procedural-macro-errors",
      "keywords": [
        "macro",
        "match",
        "result",
        "struct",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "span-information": {
      "title": "Span Information",
      "level": "expert",
      "description": "Spans track the location of code elements in source files:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "span-information",
      "keywords": [
        "macro",
        "rc",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "advanced-techniques": {
      "title": "Advanced Techniques",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "advanced-techniques",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "macro-composition": {
      "title": "Macro Composition",
      "level": "advanced",
      "description": "Macros can call other macros to build complex functionality:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "macro-composition",
      "keywords": [
        "impl",
        "macro",
        "result",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "conditional-compilation": {
      "title": "Conditional Compilation",
      "level": "advanced",
      "description": "Macros can generate different code based on conditions:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "conditional-compilation",
      "keywords": [
        "impl",
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "dsl-project"
      ]
    },
    "macro-testing": {
      "title": "Macro Testing",
      "level": "advanced",
      "description": "Testing macros requires special techniques:",
      "file_path": "advanced\\dsl-project\\CONCEPTS.md",
      "section": "macro-testing",
      "keywords": [
        " crate to test compilation:\n\n",
        "impl",
        "macro"
      ],
      "related_concepts": [
        "special-techniques"
      ],
      "projects": [
        "dsl-project"
      ]
    },
    "core-concepts": {
      "title": "Core Concepts",
      "level": "advanced",
      "description": "No description available.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "core-concepts",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "1-thread-management": {
      "title": "1. Thread Management",
      "level": "advanced",
      "description": "What it is: Managing the lifecycle of multiple threads, including creation, execution, and cleanup.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "1-thread-management",
      "keywords": [
        "\n\n**key points:**\n- use ",
        "impl",
        "map",
        "rc",
        "string",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "2-shared-state-with-arc-and-mutex": {
      "title": "2. Shared State with Arc and Mutex",
      "level": "advanced",
      "description": "What it is: Arc<T> (Atomically Reference Counted) allows multiple owners of the same data, while Mutex<T> provides mutual exclusion for safe concurrent access.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "2-shared-state-with-arc-and-mutex",
      "keywords": [
        "\n\n**key points:**\n- ",
        "arc",
        "arc<t>",
        "impl",
        "mutex",
        "mutex<t>",
        "ownership",
        "rc",
        "reference",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "3-message-passing-with-channels": {
      "title": "3. Message Passing with Channels",
      "level": "advanced",
      "description": "What it is: Channels provide a way to send data between threads safely using the mpsc (multiple producer, single consumer) module.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "3-message-passing-with-channels",
      "keywords": [
        "impl",
        "map",
        "mpsc",
        "ownership",
        "string",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "4-raii-resource-acquisition-is-initialization": {
      "title": "4. RAII (Resource Acquisition Is Initialization)",
      "level": "advanced",
      "description": "What it is: A programming pattern where resource cleanup is tied to object destruction, implemented through the Drop trait.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "4-raii-resource-acquisition-is-initialization",
      "keywords": [
        "\n\n**key points:**\n- ",
        "drop",
        "impl",
        "rc",
        "struct",
        "thread",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "5-error-handling-in-concurrent-contexts": {
      "title": "5. Error Handling in Concurrent Contexts",
      "level": "advanced",
      "description": "What it is: Properly handling errors that can occur in multi-threaded environments, including thread creation failures and communication errors.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "5-error-handling-in-concurrent-contexts",
      "keywords": [
        "arc",
        "enum",
        "impl",
        "match",
        "rc",
        "result",
        "string",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "6-panic-handling": {
      "title": "6. Panic Handling",
      "level": "advanced",
      "description": "What it is: Preventing panics in one thread from crashing the entire application.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "6-panic-handling",
      "keywords": [
        "\n\n**key points:**\n- use ",
        " to isolate panics\n- ",
        "closure",
        "impl",
        "result",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "7-graceful-shutdown": {
      "title": "7. Graceful Shutdown",
      "level": "advanced",
      "description": "What it is: Cleanly stopping all threads and ensuring no work is lost during shutdown.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "7-graceful-shutdown",
      "keywords": [
        "impl",
        "thread",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "8-generic-programming": {
      "title": "8. Generic Programming",
      "level": "advanced",
      "description": "What it is: Writing code that works with multiple types, using generics and trait bounds.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "8-generic-programming",
      "keywords": [
        "\n\n**key points:**\n- ",
        ")\n- ",
        "box",
        "closure",
        "generic",
        "impl",
        "lifetime",
        "reference",
        "result",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "advanced-concepts": {
      "title": "Advanced Concepts",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "advanced-concepts",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "work-stealing-extension": {
      "title": "Work Stealing (Extension)",
      "level": "advanced",
      "description": "What it is: Idle workers can \"steal\" work from busy workers' queues to improve load balancing.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "work-stealing-extension",
      "keywords": [
        "impl"
      ],
      "related_concepts": [
        "more-complex-synchronization-but-can-improve-performance"
      ],
      "projects": [
        "thread-pool"
      ]
    },
    "lock-free-programming": {
      "title": "Lock-Free Programming",
      "level": "advanced",
      "description": "What it is: Using atomic operations instead of locks for better performance in high-contention scenarios.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "lock-free-programming",
      "keywords": [
        "impl"
      ],
      "related_concepts": [
        "careful-design-to-avoid-aba-problems-and-memory-ordering-issues"
      ],
      "projects": [
        "thread-pool"
      ]
    },
    "thread-local-storage": {
      "title": "Thread-Local Storage",
      "level": "advanced",
      "description": "What it is: Data that is unique to each thread, avoiding the need for synchronization.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "thread-local-storage",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "lock-contention": {
      "title": "Lock Contention",
      "level": "advanced",
      "description": "Problem: Multiple threads waiting for the same lock reduces parallelism.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "lock-contention",
      "keywords": [
        "impl",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "thread-creation-overhead": {
      "title": "Thread Creation Overhead",
      "level": "advanced",
      "description": "Problem: Creating threads is expensive.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "thread-creation-overhead",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "context-switching": {
      "title": "Context Switching",
      "level": "advanced",
      "description": "Problem: Too many threads can cause excessive context switching.",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "context-switching",
      "keywords": [
        "match",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "testing-concurrent-code": {
      "title": "Testing Concurrent Code",
      "level": "intermediate",
      "description": "use std::sync::atomic::{AtomicUsize, Ordering};",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "testing-concurrent-code",
      "keywords": [
        "arc",
        "collect",
        "map",
        "rc",
        "result",
        "thread",
        "unwrap",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "challenges": {
      "title": "Challenges",
      "level": "advanced",
      "description": "- Non-deterministic execution order",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "challenges",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "strategies": {
      "title": "Strategies",
      "level": "advanced",
      "description": "- Use barriers to synchronize test execution",
      "file_path": "advanced\\thread-pool\\CONCEPTS.md",
      "section": "strategies",
      "keywords": [
        "rc",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "thread-pool"
      ]
    },
    "1-variables-and-data-types": {
      "title": "1. Variables and Data Types",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "1-variables-and-data-types",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "variables": {
      "title": "Variables",
      "level": "basic",
      "description": "In Rust, variables are immutable by default. To make them mutable, you use the mut keyword:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "variables",
      "keywords": [
        "immutable",
        "mut",
        "mutable",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "2-enums-and-pattern-matching": {
      "title": "2. Enums and Pattern Matching",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "2-enums-and-pattern-matching",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "3-structs": {
      "title": "3. Structs",
      "level": "basic",
      "description": "Structs are used to create custom data types that group related values:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "3-structs",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "4-error-handling": {
      "title": "4. Error Handling",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "4-error-handling",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "custom-error-types": {
      "title": "Custom Error Types",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "custom-error-types",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "result-type": {
      "title": "Result Type",
      "level": "basic",
      "description": "The Result<T, E> type is used for operations that can fail:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "result-type",
      "keywords": [
        "result",
        "result<t, e>",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "5-functions-and-methods": {
      "title": "5. Functions and Methods",
      "level": "basic",
      "description": "Functions in Rust are defined using the fn keyword:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "5-functions-and-methods",
      "keywords": [
        "fn",
        "impl",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "6-string-manipulation": {
      "title": "6. String Manipulation",
      "level": "basic",
      "description": "The calculator project involves several string operations:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "6-string-manipulation",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "7-documentation-comments": {
      "title": "7. Documentation Comments",
      "level": "basic",
      "description": "Rust has a special syntax for documentation comments that can be processed by tools like rustdoc:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "7-documentation-comments",
      "keywords": [
        "rustdoc",
        "slice",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "8-ownership-and-borrowing": {
      "title": "8. Ownership and Borrowing",
      "level": "basic",
      "description": "The calculator demonstrates Rust's ownership system:",
      "file_path": "basic\\module1\\calculator\\CONCEPTS.md",
      "section": "8-ownership-and-borrowing",
      "keywords": [
        "&calculation",
        "&str",
        "borrowing",
        "calculation",
        "ownership",
        "reference",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "calculator"
      ]
    },
    "9-standard-library-usage": {
      "title": "9. Standard Library Usage",
      "level": "basic",
      "description": "The project uses several components from Rust's standard library:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "9-standard-library-usage",
      "keywords": [
        "std::env",
        "std::fs",
        "std::io",
        "std::path"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "file-system-operations": {
      "title": "File System Operations",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module1\\file-explorer\\CONCEPTS.md",
      "section": "file-system-operations",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "file-explorer"
      ]
    },
    "overview": {
      "title": "Overview",
      "level": "intermediate",
      "description": "Rust's standard library provides several collection types that store multiple values. The most common are Vec (vector), HashMap, and HashSet, each with different performance characteristics and use ca...",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "overview",
      "keywords": [
        "collect",
        "map",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "how-its-used-in-this-project": {
      "title": "How it's used in this project",
      "level": "intermediate",
      "description": "The Library Management System uses collections to store and manage books and users.",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "how-its-used-in-this-project",
      "keywords": [
        "arc",
        "collect",
        "filter",
        "impl",
        "rc",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "key-points-to-understand": {
      "title": "Key points to understand",
      "level": "intermediate",
      "description": "- Vec<T> is a growable array type",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "key-points-to-understand",
      "keywords": [
        "collect",
        "iterator",
        "vec",
        "vec<t>"
      ],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "path-manipulation": {
      "title": "Path Manipulation",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module1\\file-explorer\\CONCEPTS.md",
      "section": "path-manipulation",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "file-explorer"
      ]
    },
    "error-handling": {
      "title": "Error Handling",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "error-handling",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "user-input-and-output": {
      "title": "User Input and Output",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module1\\file-explorer\\CONCEPTS.md",
      "section": "user-input-and-output",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "file-explorer"
      ]
    },
    "command-parsing": {
      "title": "Command Parsing",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module1\\file-explorer\\CONCEPTS.md",
      "section": "command-parsing",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "file-explorer"
      ]
    },
    "related-concepts": {
      "title": "Related Concepts",
      "level": "intermediate",
      "description": "- Smart Pointers: Types like Box<T>, Rc<T>, and Arc<T> for more complex memory management scenarios",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "related-concepts",
      "keywords": [
        "arc",
        "arc<t>",
        "box",
        "box<t>",
        "generic",
        "immutable",
        "mutable",
        "rc",
        "rc<t>",
        "refcell"
      ],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "glossary": {
      "title": "Glossary",
      "level": "intermediate",
      "description": "- Ownership: Rust's system for managing memory through strict rules about which part of code owns each piece of data",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "glossary",
      "keywords": [
        "borrowing",
        "immutable",
        "lifetime",
        "mutable",
        "ownership",
        "rc",
        "reference"
      ],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "1-string-manipulation": {
      "title": "1. String Manipulation",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "1-string-manipulation",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "string-types": {
      "title": "String Types",
      "level": "basic",
      "description": "Rust has two main string types:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "string-types",
      "keywords": [
        "&str",
        "reference",
        "slice",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "common-string-operations": {
      "title": "Common String Operations",
      "level": "basic",
      "description": "The text processor uses several string manipulation methods:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "common-string-operations",
      "keywords": [
        "collect",
        "rc",
        "string",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "2-file-io": {
      "title": "2. File I/O",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "2-file-io",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "reading-files": {
      "title": "Reading Files",
      "level": "basic",
      "description": "Rust provides several ways to read files:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "reading-files",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "writing-files": {
      "title": "Writing Files",
      "level": "basic",
      "description": "Similarly, there are multiple ways to write to files:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "writing-files",
      "keywords": [
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "3-error-handling": {
      "title": "3. Error Handling",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "3-error-handling",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "4-command-line-argument-parsing": {
      "title": "4. Command-Line Argument Parsing",
      "level": "basic",
      "description": "Rust provides access to command-line arguments through std::env::args():",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "4-command-line-argument-parsing",
      "keywords": [
        "collect",
        "std::env::args()",
        "string",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "5-traits-and-generics": {
      "title": "5. Traits and Generics",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "5-traits-and-generics",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "6-closures": {
      "title": "6. Closures",
      "level": "basic",
      "description": "Closures are anonymous functions that can capture their environment:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "6-closures",
      "keywords": [
        "closure",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "7-iterators": {
      "title": "7. Iterators",
      "level": "basic",
      "description": "Iterators provide a way to process sequences of items:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "7-iterators",
      "keywords": [
        "collect",
        "filter",
        "iterator",
        "match",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "8-resource-management": {
      "title": "8. Resource Management",
      "level": "basic",
      "description": "Rust's ownership system ensures resources are properly managed:",
      "file_path": "basic\\module2\\text-processor\\CONCEPTS.md",
      "section": "8-resource-management",
      "keywords": [
        "ownership",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "text-processor"
      ]
    },
    "structs-in-rust": {
      "title": "Structs in Rust",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "structs-in-rust",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "what-are-structs": {
      "title": "What are Structs?",
      "level": "basic",
      "description": "Structs (short for \"structures\") are custom data types that let you package together and name multiple related values. They're similar to classes in object-oriented languages but with some key differe...",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "what-are-structs",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "types-of-structs-in-rust": {
      "title": "Types of Structs in Rust",
      "level": "basic",
      "description": "1. Named-Field Structs: The most common type, with named fields.",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "types-of-structs-in-rust",
      "keywords": [
        "impl",
        "string",
        "struct",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "struct-implementation-in-our-project": {
      "title": "Struct Implementation in Our Project",
      "level": "basic",
      "description": "In our To-Do List application, we use two main structs:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "struct-implementation-in-our-project",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "1-the-task-struct": {
      "title": "1. The `Task` Struct",
      "level": "basic",
      "description": "pub description: Option<String>,",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "1-the-task-struct",
      "keywords": [
        ")\n- a creation timestamp (",
        ")\n- a status (",
        ")\n- a title (",
        ")\n- an optional description (",
        "enum",
        "option",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "2-the-tasklist-struct": {
      "title": "2. The `TaskList` Struct",
      "level": "basic",
      "description": "pub struct TaskList {",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "2-the-tasklist-struct",
      "keywords": [
        "collect",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "methods-on-structs": {
      "title": "Methods on Structs",
      "level": "basic",
      "description": "Rust allows you to define methods on structs using impl blocks:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "methods-on-structs",
      "keywords": [
        " or ",
        "), borrow immutably (",
        "), or borrow mutably (",
        "impl",
        "option",
        "ownership",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "enums-in-rust": {
      "title": "Enums in Rust",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "enums-in-rust",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "what-are-enums": {
      "title": "What are Enums?",
      "level": "basic",
      "description": "Enums (short for \"enumerations\") allow you to define a type by enumerating its possible variants. They're particularly powerful in Rust because each variant can have different associated data.",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "what-are-enums",
      "keywords": [
        "enum"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "basic-enum-usage": {
      "title": "Basic Enum Usage",
      "level": "basic",
      "description": "This defines a type TaskStatus that can only be one of three values.",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "basic-enum-usage",
      "keywords": [
        "\n\nthis defines a type ",
        "enum"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "enum-implementation-in-our-project": {
      "title": "Enum Implementation in Our Project",
      "level": "basic",
      "description": "In our To-Do List application, we use the TaskStatus enum:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "enum-implementation-in-our-project",
      "keywords": [
        "enum",
        "taskstatus"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "pattern-matching-with-enums": {
      "title": "Pattern Matching with Enums",
      "level": "basic",
      "description": "Enums are often used with pattern matching via the match expression:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "pattern-matching-with-enums",
      "keywords": [
        " implementation for ",
        ":\n\n",
        "enum",
        "impl",
        "match",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "ownership-concepts-in-the-project": {
      "title": "Ownership Concepts in the Project",
      "level": "basic",
      "description": "No description available.",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "ownership-concepts-in-the-project",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "ownership-and-borrowing": {
      "title": "Ownership and Borrowing",
      "level": "basic",
      "description": "- Ownership Rules: Understanding who owns data and when it's dropped",
      "file_path": "basic\\module4\\capstone\\CONCEPTS.md",
      "section": "ownership-and-borrowing",
      "keywords": [
        "&",
        "&mut",
        "borrowing",
        "impl",
        "lifetime",
        "option",
        "ownership",
        "reference"
      ],
      "related_concepts": [],
      "projects": []
    },
    "option-type": {
      "title": "Option Type",
      "level": "basic",
      "description": "The Option type is used extensively to handle cases where a value might be absent:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "option-type",
      "keywords": [
        "option",
        "rc",
        "reference",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "working-with-vectors": {
      "title": "Working with Vectors",
      "level": "basic",
      "description": "The project demonstrates several vector operations:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "working-with-vectors",
      "keywords": [
        "collect",
        "filter",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "display-trait": {
      "title": "Display Trait",
      "level": "basic",
      "description": "We implement the Display trait for both Task and TaskStatus to provide string representations:",
      "file_path": "basic\\module3\\todo-app\\CONCEPTS.md",
      "section": "display-trait",
      "keywords": [
        " format specifier in ",
        "display",
        "impl",
        "macro",
        "result",
        "string",
        "task",
        "taskstatus",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "todo-app"
      ]
    },
    "debug-trait": {
      "title": "Debug Trait",
      "level": "intermediate",
      "description": "Allows printing with {:?} format specifier:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "debug-trait",
      "keywords": [
        "\n\nnote the trait bound ",
        "impl",
        "map",
        "result",
        "trait",
        "unsafe",
        "vec",
        "{:?}"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "basic-syntax-and-control-flow": {
      "title": "Basic Syntax and Control Flow",
      "level": "basic",
      "description": "- Variables and Mutability: Using let and mut for variable declarations",
      "file_path": "basic\\module4\\capstone\\CONCEPTS.md",
      "section": "basic-syntax-and-control-flow",
      "keywords": [
        "else",
        "if",
        "let",
        "match",
        "mut",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "structs-and-methods": {
      "title": "Structs and Methods",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "structs-and-methods",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "enums-and-pattern-matching": {
      "title": "Enums and Pattern Matching",
      "level": "basic",
      "description": "- Enum Definition: Creating custom types with variants",
      "file_path": "basic\\module4\\capstone\\CONCEPTS.md",
      "section": "enums-and-pattern-matching",
      "keywords": [
        "enum",
        "match",
        "option",
        "result",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "traits-and-trait-implementations": {
      "title": "Traits and Trait Implementations",
      "level": "basic",
      "description": "- Trait Implementation: Implementing traits like Display and Error",
      "file_path": "basic\\module4\\capstone\\CONCEPTS.md",
      "section": "traits-and-trait-implementations",
      "keywords": [
        "#[derive(...)]",
        "display",
        "error",
        "impl",
        "result",
        "trait"
      ],
      "related_concepts": [],
      "projects": []
    },
    "file-io": {
      "title": "File I/O",
      "level": "basic",
      "description": "- File Operations: Reading from and writing to files",
      "file_path": "basic\\module4\\capstone\\CONCEPTS.md",
      "section": "file-io",
      "keywords": [
        "map",
        "result",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "testing": {
      "title": "Testing",
      "level": "basic",
      "description": "- Unit Tests: Testing individual components in isolation",
      "file_path": "basic\\module4\\capstone\\CONCEPTS.md",
      "section": "testing",
      "keywords": [
        "string",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": []
    },
    "external-crates-and-dependencies": {
      "title": "External Crates and Dependencies",
      "level": "basic",
      "description": "- Using External Libraries: Adding and using dependencies from crates.io",
      "file_path": "basic\\module4\\capstone\\CONCEPTS.md",
      "section": "external-crates-and-dependencies",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "asyncawait-fundamentals": {
      "title": "Async/Await Fundamentals",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "asyncawait-fundamentals",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "what-is-async-programming": {
      "title": "What is Async Programming?",
      "level": "expert",
      "description": "Asynchronous programming allows a program to handle multiple operations concurrently without blocking. Instead of waiting for one operation to complete before starting another, async programming enabl...",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "what-is-async-programming",
      "keywords": [
        "async"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "the-async-keyword": {
      "title": "The `async` Keyword",
      "level": "expert",
      "description": "The async keyword transforms a function into an asynchronous function that returns a Future:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "the-async-keyword",
      "keywords": [
        "async",
        "future",
        "string"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "the-await-keyword": {
      "title": "The `await` Keyword",
      "level": "expert",
      "description": "The await keyword is used to wait for a Future to complete:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "the-await-keyword",
      "keywords": [
        "\n\n**key points:**\n- ",
        " can only be used inside ",
        " functions\n- ",
        "async",
        "await",
        "future",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "futures-and-the-runtime": {
      "title": "Futures and the Runtime",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "futures-and-the-runtime",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "what-is-a-future": {
      "title": "What is a Future?",
      "level": "expert",
      "description": "A Future in Rust represents a computation that will complete at some point in the future. Unlike promises in other languages, Rust futures are \"lazy\" - they don't do any work until they're polled.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "what-is-a-future",
      "keywords": [
        "future",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "future-states": {
      "title": "Future States",
      "level": "expert",
      "description": "A Future can be in one of two states:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "future-states",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "the-runtimes-role": {
      "title": "The Runtime's Role",
      "level": "expert",
      "description": "The async runtime is responsible for:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "the-runtimes-role",
      "keywords": [
        "async",
        "impl",
        "match"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "tokio-runtime": {
      "title": "Tokio Runtime",
      "level": "expert",
      "description": "use tokio::runtime::Runtime;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "tokio-runtime",
      "keywords": [
        "async",
        "await",
        "macro",
        "result",
        "thread",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": []
    },
    "what-is-tokio": {
      "title": "What is Tokio?",
      "level": "expert",
      "description": "Tokio is the most popular async runtime for Rust. It provides:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "what-is-tokio",
      "keywords": [
        "async",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "runtime-types": {
      "title": "Runtime Types",
      "level": "expert",
      "description": "Tokio offers different runtime configurations:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "runtime-types",
      "keywords": [
        "async",
        "thread",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "task-spawning": {
      "title": "Task Spawning",
      "level": "expert",
      "description": "async fn task_spawning_examples() {",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "task-spawning",
      "keywords": [
        "async",
        "await",
        "result",
        "thread"
      ],
      "related_concepts": [],
      "projects": []
    },
    "async-io-operations": {
      "title": "Async I/O Operations",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "async-io-operations",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "non-blocking-io": {
      "title": "Non-blocking I/O",
      "level": "expert",
      "description": "Traditional I/O operations block the calling thread:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "non-blocking-io",
      "keywords": [
        "async",
        "await",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "async-traits": {
      "title": "Async Traits",
      "level": "expert",
      "description": "Tokio provides async versions of standard I/O traits:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "async-traits",
      "keywords": [
        "async",
        "asyncbufread",
        "asyncread",
        "asyncwrite",
        "await",
        "box",
        "result",
        "std::io::bufread",
        "std::io::read",
        "std::io::write"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "concurrency-vs-parallelism": {
      "title": "Concurrency vs Parallelism",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "concurrency-vs-parallelism",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "concurrency": {
      "title": "Concurrency",
      "level": "expert",
      "description": "Concurrency is about dealing with multiple things at once (but not necessarily simultaneously):",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "concurrency",
      "keywords": [
        "async",
        "await",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "parallelism": {
      "title": "Parallelism",
      "level": "expert",
      "description": "Parallelism is about doing multiple things simultaneously (requires multiple CPU cores):",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "parallelism",
      "keywords": [
        "async",
        "result",
        "thread"
      ],
      "related_concepts": [
        "multiple-cpu-cores"
      ],
      "projects": [
        "async-network-server"
      ]
    },
    "when-to-use-each": {
      "title": "When to Use Each",
      "level": "expert",
      "description": "- Async/Concurrency: I/O-bound operations (network, file system, database)",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "when-to-use-each",
      "keywords": [
        "async",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "error-handling-in-async-code": {
      "title": "Error Handling in Async Code",
      "level": "expert",
      "description": "use std::error::Error;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "error-handling-in-async-code",
      "keywords": [
        "async",
        "await",
        "box",
        "match",
        "result"
      ],
      "related_concepts": [],
      "projects": []
    },
    "handling-task-errors": {
      "title": "Handling Task Errors",
      "level": "expert",
      "description": "Spawned tasks can fail independently:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "handling-task-errors",
      "keywords": [
        "async",
        "await",
        "match",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "timeout-handling": {
      "title": "Timeout Handling",
      "level": "expert",
      "description": "use tokio::time::{timeout, Duration};",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "timeout-handling",
      "keywords": [
        "async",
        "await",
        "impl",
        "match",
        "result",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "memory-usage": {
      "title": "Memory Usage",
      "level": "expert",
      "description": "Consider memory usage patterns:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "memory-usage",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "task-overhead": {
      "title": "Task Overhead",
      "level": "expert",
      "description": "While tasks are lightweight, they still have overhead:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "task-overhead",
      "keywords": [
        "async",
        "await",
        "collect",
        "impl",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "blocking-operations": {
      "title": "Blocking Operations",
      "level": "expert",
      "description": "Never block the async runtime with synchronous operations:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "blocking-operations",
      "keywords": [
        "async",
        "await",
        "result",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "common-patterns-and-best-practices": {
      "title": "Common Patterns and Best Practices",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "common-patterns-and-best-practices",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "connection-pooling": {
      "title": "Connection Pooling",
      "level": "expert",
      "description": "Reuse connections to improve performance:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "connection-pooling",
      "keywords": [
        "arc",
        "async",
        "await",
        "impl",
        "mutex",
        "option",
        "rc",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "graceful-shutdown": {
      "title": "Graceful Shutdown",
      "level": "expert",
      "description": "Handle shutdown signals properly:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "graceful-shutdown",
      "keywords": [
        "async",
        "await"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "rate-limiting": {
      "title": "Rate Limiting",
      "level": "expert",
      "description": "Control the rate of operations:",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "rate-limiting",
      "keywords": [
        "async",
        "await"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "key-takeaways": {
      "title": "Key Takeaways",
      "level": "expert",
      "description": "1. Async is for I/O: Use async for I/O-bound operations, not CPU-bound ones",
      "file_path": "expert\\async-network-server\\CONCEPTS.md",
      "section": "key-takeaways",
      "keywords": [
        "async",
        "impl",
        "rc",
        "tokio-test"
      ],
      "related_concepts": [],
      "projects": [
        "async-network-server"
      ]
    },
    "compiler-architecture": {
      "title": "Compiler Architecture",
      "level": "expert",
      "description": "The Rust compiler follows a multi-stage pipeline:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "compiler-architecture",
      "keywords": [
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "compilation-stages": {
      "title": "Compilation Stages",
      "level": "expert",
      "description": "1. Lexing: Converting source text into tokens",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "compilation-stages",
      "keywords": [
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "plugin-integration-points": {
      "title": "Plugin Integration Points",
      "level": "expert",
      "description": "Compiler plugins typically operate at the AST level, allowing them to:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "plugin-integration-points",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "abstract-syntax-trees-ast": {
      "title": "Abstract Syntax Trees (AST)",
      "level": "expert",
      "description": "An AST is a tree representation of the syntactic structure of source code. Each node represents a construct in the programming language.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "abstract-syntax-trees-ast",
      "keywords": [
        "rc",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "ast-node-types-in-rust": {
      "title": "AST Node Types in Rust",
      "level": "expert",
      "description": "// Examples of AST nodes from the syn crate",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "ast-node-types-in-rust",
      "keywords": [
        "enum",
        "match",
        "rc",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "traversing-asts": {
      "title": "Traversing ASTs",
      "level": "expert",
      "description": "The visitor pattern is commonly used to traverse ASTs:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "traversing-asts",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "working-with-token-streams": {
      "title": "Working with Token Streams",
      "level": "expert",
      "description": "use proc_macro2::TokenStream;",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "working-with-token-streams",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "diagnostic-system": {
      "title": "Diagnostic System",
      "level": "expert",
      "description": "The diagnostic system provides feedback to developers about their code. It includes errors, warnings, and informational messages.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "diagnostic-system",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "diagnostic-components": {
      "title": "Diagnostic Components",
      "level": "expert",
      "description": "1. Level: Error, Warning, Info",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "diagnostic-components",
      "keywords": [
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "creating-diagnostics": {
      "title": "Creating Diagnostics",
      "level": "expert",
      "description": "pub struct Diagnostic {",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "creating-diagnostics",
      "keywords": [
        "impl",
        "option",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "static-analysis": {
      "title": "Static Analysis",
      "level": "expert",
      "description": "Static analysis examines code without executing it. Compiler plugins perform static analysis to detect issues and suggest improvements.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "static-analysis",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "types-of-analysis": {
      "title": "Types of Analysis",
      "level": "expert",
      "description": "1. Syntactic Analysis: Based on code structure",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "types-of-analysis",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "analysis-techniques": {
      "title": "Analysis Techniques",
      "level": "expert",
      "description": "- Pattern Matching: Detecting specific code patterns",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "analysis-techniques",
      "keywords": [
        "collect",
        "match",
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "visitor-pattern": {
      "title": "Visitor Pattern",
      "level": "expert",
      "description": "The visitor pattern separates algorithms from the data structures they operate on. It's essential for AST traversal.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "visitor-pattern",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "implementation": {
      "title": "Implementation",
      "level": "expert",
      "description": "pub trait Visit<'ast> {",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "implementation",
      "keywords": [
        "match",
        "struct",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "custom-visitors": {
      "title": "Custom Visitors",
      "level": "expert",
      "description": "impl<'ast> Visit<'ast> for MyLinter {",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "custom-visitors",
      "keywords": [
        "impl",
        "string",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "compiler-apis": {
      "title": "Compiler APIs",
      "level": "expert",
      "description": "Rust provides various APIs for interacting with the compiler, though many are unstable and require nightly Rust.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "compiler-apis",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "stable-apis": {
      "title": "Stable APIs",
      "level": "expert",
      "description": "- syn: Parsing Rust syntax",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "stable-apis",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "unstable-apis-nightly-only": {
      "title": "Unstable APIs (Nightly Only)",
      "level": "expert",
      "description": "- rustc_ast: Compiler's AST representation",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "unstable-apis-nightly-only",
      "keywords": [
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "using-stable-apis": {
      "title": "Using Stable APIs",
      "level": "expert",
      "description": "use syn::{parse_quote, ItemFn};",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "using-stable-apis",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "hygiene": {
      "title": "Hygiene",
      "level": "expert",
      "description": "Procedural macros must be hygienic - they shouldn't accidentally capture or interfere with identifiers in the calling code:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "hygiene",
      "keywords": [
        "macro"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "integration-with-development-tools": {
      "title": "Integration with Development Tools",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "integration-with-development-tools",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "ide-support": {
      "title": "IDE Support",
      "level": "expert",
      "description": "Modern IDEs can integrate with compiler plugins to provide:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "ide-support",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "continuous-integration": {
      "title": "Continuous Integration",
      "level": "expert",
      "description": "Compiler plugins can be integrated into CI pipelines to:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "continuous-integration",
      "keywords": [
        "rc"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "custom-tooling": {
      "title": "Custom Tooling",
      "level": "expert",
      "description": "Plugins can be the foundation for custom development tools:",
      "file_path": "expert\\compiler-plugin\\CONCEPTS.md",
      "section": "custom-tooling",
      "keywords": [
        "collect"
      ],
      "related_concepts": [],
      "projects": [
        "compiler-plugin"
      ]
    },
    "futures-and-the-future-trait": {
      "title": "Futures and the Future Trait",
      "level": "expert",
      "description": "A Future in Rust represents a value that will be available at some point in the future. Unlike promises in other languages, Rust futures are lazy - they don't do any work until they're polled.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "futures-and-the-future-trait",
      "keywords": [],
      "related_concepts": [],
      "projects": []
    },
    "key-characteristics": {
      "title": "Key Characteristics",
      "level": "expert",
      "description": "- Lazy: Futures don't execute until polled",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "key-characteristics",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "example-from-our-code": {
      "title": "Example from Our Code",
      "level": "expert",
      "description": "impl Future for Timer {",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "example-from-our-code",
      "keywords": [
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "polling-and-state-machines": {
      "title": "Polling and State Machines",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "polling-and-state-machines",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "the-polling-model": {
      "title": "The Polling Model",
      "level": "expert",
      "description": "Rust's async system is based on cooperative polling:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "the-polling-model",
      "keywords": [
        "async"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "state-machine-transformation": {
      "title": "State Machine Transformation",
      "level": "expert",
      "description": "When you write async code, the compiler transforms it into a state machine:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "state-machine-transformation",
      "keywords": [
        "async",
        "await",
        "enum"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "benefits": {
      "title": "Benefits",
      "level": "expert",
      "description": "- Memory Efficiency: Only pages that are accessed are loaded into physical memory",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "benefits",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "pin-and-unpin": {
      "title": "Pin and Unpin",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "pin-and-unpin",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "why-pin-exists": {
      "title": "Why Pin Exists",
      "level": "expert",
      "description": "Some futures contain self-referential data - pointers to their own fields. Moving such futures would invalidate these pointers, causing memory safety issues.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "why-pin-exists",
      "keywords": [
        "\n}\n",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "pint": {
      "title": "Pin<T>",
      "level": "expert",
      "description": "Pin<T> is a wrapper that prevents moving the wrapped value:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "pint",
      "keywords": [
        "pin<t>"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "unpin-trait": {
      "title": "Unpin Trait",
      "level": "expert",
      "description": "Types that are safe to move even when pinned implement Unpin:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "unpin-trait",
      "keywords": [
        "impl",
        "reference",
        "struct",
        "unpin"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "in-our-code": {
      "title": "In Our Code",
      "level": "expert",
      "description": "// We use Pin<Box<dyn Future>> to handle any future type",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "in-our-code",
      "keywords": [
        "box",
        "reference"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "wakers-and-context": {
      "title": "Wakers and Context",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "wakers-and-context",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "the-waker-system": {
      "title": "The Waker System",
      "level": "expert",
      "description": "Wakers enable efficient async I/O by allowing futures to register callbacks:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "the-waker-system",
      "keywords": [
        "async",
        "poll::pending"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "context": {
      "title": "Context",
      "level": "expert",
      "description": "Context provides the future with access to the waker:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "context",
      "keywords": [
        "context"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "our-custom-waker": {
      "title": "Our Custom Waker",
      "level": "expert",
      "description": "pub struct TaskWaker {",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "our-custom-waker",
      "keywords": [
        "arc",
        "impl",
        "rc",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "waker-vtable": {
      "title": "Waker Vtable",
      "level": "expert",
      "description": "Wakers use a vtable for dynamic dispatch:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "waker-vtable",
      "keywords": [
        "rc",
        "reference"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "executors-and-task-scheduling": {
      "title": "Executors and Task Scheduling",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "executors-and-task-scheduling",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "executor-responsibilities": {
      "title": "Executor Responsibilities",
      "level": "expert",
      "description": "An executor manages the lifecycle of async tasks:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "executor-responsibilities",
      "keywords": [
        "async"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "our-simple-executor": {
      "title": "Our Simple Executor",
      "level": "expert",
      "description": "pub fn run(&mut self) -> usize {",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "our-simple-executor",
      "keywords": [
        "match"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "scheduling-strategies": {
      "title": "Scheduling Strategies",
      "level": "expert",
      "description": "Different executors use different scheduling approaches:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "scheduling-strategies",
      "keywords": [
        "impl",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "real-world-executors": {
      "title": "Real-World Executors",
      "level": "expert",
      "description": "- Tokio: Multi-threaded, work-stealing, I/O integrated",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "real-world-executors",
      "keywords": [
        "async",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "cooperative-vs-preemptive-multitasking": {
      "title": "Cooperative vs Preemptive Multitasking",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "cooperative-vs-preemptive-multitasking",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "cooperative-multitasking": {
      "title": "Cooperative Multitasking",
      "level": "expert",
      "description": "In async Rust, tasks voluntarily yield control:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "cooperative-multitasking",
      "keywords": [
        "async",
        "await"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "drawbacks": {
      "title": "Drawbacks",
      "level": "expert",
      "description": "- Blocking: One blocking task stops all tasks",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "drawbacks",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "yield-points": {
      "title": "Yield Points",
      "level": "expert",
      "description": "Tasks yield control at .await points:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "yield-points",
      "keywords": [
        ".await",
        "await",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "memory-management-in-async-code": {
      "title": "Memory Management in Async Code",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "memory-management-in-async-code",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "heap-allocation": {
      "title": "Heap Allocation",
      "level": "expert",
      "description": "Our executor uses Pin<Box<dyn Future>> for type erasure:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "heap-allocation",
      "keywords": [
        "box",
        "pin<box<dyn future>>"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "zero-cost-abstractions": {
      "title": "Zero-Cost Abstractions",
      "level": "intermediate",
      "description": "Rust's generics and traits compile to the same code as if you wrote type-specific versions manually. There's no runtime overhead for using these abstractions.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "zero-cost-abstractions",
      "keywords": [
        "generic",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "lifetime-management": {
      "title": "Lifetime Management",
      "level": "expert",
      "description": "Async code must carefully manage lifetimes:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "lifetime-management",
      "keywords": [
        "async",
        "await",
        "lifetime"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "send-and-sync-bounds": {
      "title": "Send and Sync Bounds",
      "level": "expert",
      "description": "Futures that cross thread boundaries need Send:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "send-and-sync-bounds",
      "keywords": [
        "send",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "polling-overhead": {
      "title": "Polling Overhead",
      "level": "expert",
      "description": "Each poll has some overhead:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "polling-overhead",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "batching": {
      "title": "Batching",
      "level": "expert",
      "description": "Real executors batch operations:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "batching",
      "keywords": [
        "collect",
        "filter",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "io-integration": {
      "title": "I/O Integration",
      "level": "expert",
      "description": "Production runtimes integrate with OS I/O:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "io-integration",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "cpu-usage": {
      "title": "CPU Usage",
      "level": "expert",
      "description": "Async is great for I/O-bound workloads but consider:",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "cpu-usage",
      "keywords": [
        "async",
        "spawn_blocking"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "do": {
      "title": "Do",
      "level": "expert",
      "description": "- Use .await for yield points",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "do",
      "keywords": [
        ".await",
        "async",
        "await",
        "future",
        "impl"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "dont": {
      "title": "Don't",
      "level": "expert",
      "description": "- Block in async code without spawn_blocking",
      "file_path": "expert\\custom-runtime\\CONCEPTS.md",
      "section": "dont",
      "keywords": [
        "async",
        "pin",
        "send",
        "spawn_blocking",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "custom-runtime"
      ]
    },
    "memory-mapped-files": {
      "title": "Memory-Mapped Files",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "memory-mapped-files",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "concept": {
      "title": "Concept",
      "level": "expert",
      "description": "Zero-copy operations avoid unnecessary data copying, reducing memory allocations and improving performance.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "concept",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "how-it-works": {
      "title": "How It Works",
      "level": "expert",
      "description": "// Process 4 f64 values simultaneously",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "how-it-works",
      "keywords": [
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "when-to-use": {
      "title": "When to Use",
      "level": "expert",
      "description": "- Processing large files (> 100MB)",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "when-to-use",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "trade-offs": {
      "title": "Trade-offs",
      "level": "expert",
      "description": "- Complexity: Requires unsafe code and careful error handling",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "trade-offs",
      "keywords": [
        "unsafe"
      ],
      "related_concepts": [
        "unsafe-code-and-careful-error-handling"
      ],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "simd-operations": {
      "title": "SIMD Operations",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "simd-operations",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "simd-instruction-sets": {
      "title": "SIMD Instruction Sets",
      "level": "expert",
      "description": "- SSE/SSE2: 128-bit vectors (2 f64 or 4 f32 values)",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "simd-instruction-sets",
      "keywords": [
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "implementation-strategies": {
      "title": "Implementation Strategies",
      "level": "expert",
      "description": "1. Explicit SIMD: Using SIMD intrinsics directly",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "implementation-strategies",
      "keywords": [
        "vec",
        "wide"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "example-optimized-array-addition": {
      "title": "Example: Optimized Array Addition",
      "level": "expert",
      "description": "pub fn add_arrays_simd(a: &[f64], b: &[f64]) -> Vec<f64> {",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "example-optimized-array-addition",
      "keywords": [
        "result",
        "slice",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "parallel-processing": {
      "title": "Parallel Processing",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "parallel-processing",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "rayon-framework": {
      "title": "Rayon Framework",
      "level": "expert",
      "description": "Rayon provides data parallelism through parallel iterators:",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "rayon-framework",
      "keywords": [
        "collect",
        "iterator",
        "map",
        "result",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "parallelization-strategies": {
      "title": "Parallelization Strategies",
      "level": "expert",
      "description": "1. Data Parallelism: Divide data across threads",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "parallelization-strategies",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "work-stealing": {
      "title": "Work-Stealing",
      "level": "expert",
      "description": "Rayon uses work-stealing for load balancing:",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "work-stealing",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "optimal-chunk-sizes": {
      "title": "Optimal Chunk Sizes",
      "level": "expert",
      "description": "// Automatic chunking based on data size and thread count",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "optimal-chunk-sizes",
      "keywords": [
        "collect",
        "map",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "cache-optimization": {
      "title": "Cache Optimization",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "cache-optimization",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "cpu-cache-hierarchy": {
      "title": "CPU Cache Hierarchy",
      "level": "expert",
      "description": "- L1 Cache: ~32KB, 1-2 cycles latency",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "cpu-cache-hierarchy",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "cache-friendly-patterns": {
      "title": "Cache-Friendly Patterns",
      "level": "expert",
      "description": "1. Sequential Access: Access memory in order",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "cache-friendly-patterns",
      "keywords": [
        "reference",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "structure-of-arrays-vs-array-of-structures": {
      "title": "Structure of Arrays vs Array of Structures",
      "level": "expert",
      "description": "// Array of Structures (AoS) - poor cache usage",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "structure-of-arrays-vs-array-of-structures",
      "keywords": [
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "memory-prefetching": {
      "title": "Memory Prefetching",
      "level": "expert",
      "description": "// Manual prefetching for predictable access patterns",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "memory-prefetching",
      "keywords": [
        "arc",
        "rc",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "zero-copy-operations": {
      "title": "Zero-Copy Operations",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "zero-copy-operations",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "techniques": {
      "title": "Techniques",
      "level": "expert",
      "description": "1. Borrowing: Use references instead of owned data",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "techniques",
      "keywords": [
        "borrowing",
        "map",
        "reference",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "safe-transmutation-with-bytemuck": {
      "title": "Safe Transmutation with bytemuck",
      "level": "expert",
      "description": "use bytemuck::{Pod, Zeroable, cast_slice};",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "safe-transmutation-with-bytemuck",
      "keywords": [
        "slice",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "string-processing-without-allocation": {
      "title": "String Processing Without Allocation",
      "level": "expert",
      "description": "// Instead of allocating new strings",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "string-processing-without-allocation",
      "keywords": [
        "collect",
        "filter",
        "map",
        "rc",
        "slice",
        "string",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "performance-profiling": {
      "title": "Performance Profiling",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "performance-profiling",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "profiling-tools": {
      "title": "Profiling Tools",
      "level": "expert",
      "description": "1. perf (Linux): CPU profiling and performance counters",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "profiling-tools",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "using-perf-with-rust": {
      "title": "Using perf with Rust",
      "level": "expert",
      "description": "cargo build --release",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "using-perf-with-rust",
      "keywords": [
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "profiling-in-code": {
      "title": "Profiling in Code",
      "level": "expert",
      "description": "use std::time::Instant;",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "profiling-in-code",
      "keywords": [
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "memory-profiling": {
      "title": "Memory Profiling",
      "level": "expert",
      "description": "// Track memory allocations",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "memory-profiling",
      "keywords": [
        "impl",
        "struct",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "benchmarking-methodology": {
      "title": "Benchmarking Methodology",
      "level": "expert",
      "description": "No description available.",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "benchmarking-methodology",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "statistical-significance": {
      "title": "Statistical Significance",
      "level": "expert",
      "description": "- Multiple Runs: Run benchmarks multiple times",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "statistical-significance",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "criterionrs-framework": {
      "title": "Criterion.rs Framework",
      "level": "expert",
      "description": "use criterion::{black_box, criterion_group, criterion_main, Criterion};",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "criterionrs-framework",
      "keywords": [
        "box"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "avoiding-compiler-optimizations": {
      "title": "Avoiding Compiler Optimizations",
      "level": "expert",
      "description": "use criterion::black_box;",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "avoiding-compiler-optimizations",
      "keywords": [
        "box",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "measuring-throughput": {
      "title": "Measuring Throughput",
      "level": "expert",
      "description": "use criterion::{Criterion, Throughput, BenchmarkId};",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "measuring-throughput",
      "keywords": [
        "box"
      ],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "performance-regression-testing": {
      "title": "Performance Regression Testing",
      "level": "expert",
      "description": "// Store baseline performance metrics",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "performance-regression-testing",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "best-practices-summary": {
      "title": "Best Practices Summary",
      "level": "expert",
      "description": "1. Profile First: Measure before optimizing",
      "file_path": "expert\\high-performance-data-processing\\CONCEPTS.md",
      "section": "best-practices-summary",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "high-performance-data-processing"
      ]
    },
    "the-future-trait": {
      "title": "The Future Trait",
      "level": "expert",
      "description": "use std::future::Future;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "the-future-trait",
      "keywords": [
        "trait"
      ],
      "related_concepts": [],
      "projects": []
    },
    "basic-future-implementation": {
      "title": "Basic Future Implementation",
      "level": "expert",
      "description": "use std::future::Future;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "basic-future-implementation",
      "keywords": [
        "async",
        "await",
        "impl",
        "struct",
        "thread"
      ],
      "related_concepts": [],
      "projects": []
    },
    "future-combinators": {
      "title": "Future Combinators",
      "level": "expert",
      "description": "use std::future::Future;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "future-combinators",
      "keywords": [
        "async",
        "result"
      ],
      "related_concepts": [],
      "projects": []
    },
    "asyncawait-syntax": {
      "title": "Async/Await Syntax",
      "level": "expert",
      "description": "The async/await syntax provides a more readable way to work with futures, making asynchronous code look similar to synchronous code.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "asyncawait-syntax",
      "keywords": [
        "async",
        "await"
      ],
      "related_concepts": [],
      "projects": []
    },
    "async-functions": {
      "title": "Async Functions",
      "level": "expert",
      "description": "// Async function that returns a Future",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "async-functions",
      "keywords": [
        "async",
        "await",
        "box",
        "result",
        "string"
      ],
      "related_concepts": [],
      "projects": []
    },
    "pinning-and-self-referential-structs": {
      "title": "Pinning and Self-Referential Structs",
      "level": "expert",
      "description": "Pinning is crucial for async Rust because futures often contain self-references that must not be moved in memory.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "pinning-and-self-referential-structs",
      "keywords": [
        "async",
        "reference"
      ],
      "related_concepts": [],
      "projects": []
    },
    "understanding-pin": {
      "title": "Understanding Pin",
      "level": "expert",
      "description": "use std::marker::PhantomPinned;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "understanding-pin",
      "keywords": [
        "box",
        "impl",
        "string",
        "struct",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": []
    },
    "pin-in-async-context": {
      "title": "Pin in Async Context",
      "level": "expert",
      "description": "use std::future::Future;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "pin-in-async-context",
      "keywords": [
        "async",
        "box",
        "impl",
        "match",
        "string",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "async-runtimes": {
      "title": "Async Runtimes",
      "level": "expert",
      "description": "Async runtimes provide the infrastructure to execute futures. Different runtimes have different characteristics and use cases.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "async-runtimes",
      "keywords": [
        "async",
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "comparing-runtimes": {
      "title": "Comparing Runtimes",
      "level": "expert",
      "description": "// Tokio - Full-featured, production-ready",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "comparing-runtimes",
      "keywords": [
        "async",
        "await",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": []
    },
    "task-scheduling-and-execution": {
      "title": "Task Scheduling and Execution",
      "level": "expert",
      "description": "Understanding how tasks are scheduled and executed is crucial for writing efficient async code.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "task-scheduling-and-execution",
      "keywords": [
        "async"
      ],
      "related_concepts": [],
      "projects": []
    },
    "task-local-storage": {
      "title": "Task Local Storage",
      "level": "expert",
      "description": "use tokio::task_local;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "task-local-storage",
      "keywords": [
        "async",
        "await"
      ],
      "related_concepts": [],
      "projects": []
    },
    "async-streams-and-iterators": {
      "title": "Async Streams and Iterators",
      "level": "expert",
      "description": "Streams are the async equivalent of iterators, allowing you to process sequences of data asynchronously.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "async-streams-and-iterators",
      "keywords": [
        "async",
        "iterator"
      ],
      "related_concepts": [],
      "projects": []
    },
    "basic-stream-usage": {
      "title": "Basic Stream Usage",
      "level": "expert",
      "description": "use futures::stream::{self, StreamExt};",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "basic-stream-usage",
      "keywords": [
        "async",
        "await",
        "collect",
        "impl",
        "iterator",
        "map",
        "option",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": []
    },
    "interval-streams": {
      "title": "Interval Streams",
      "level": "expert",
      "description": "use tokio::time::{interval, Duration};",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "interval-streams",
      "keywords": [
        "async",
        "await"
      ],
      "related_concepts": [],
      "projects": []
    },
    "cancellation-and-timeouts": {
      "title": "Cancellation and Timeouts",
      "level": "expert",
      "description": "Proper cancellation and timeout handling is essential for robust async applications.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "cancellation-and-timeouts",
      "keywords": [
        "async"
      ],
      "related_concepts": [],
      "projects": []
    },
    "cancellation-tokens": {
      "title": "Cancellation Tokens",
      "level": "expert",
      "description": "use tokio_util::sync::CancellationToken;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "cancellation-tokens",
      "keywords": [
        "async",
        "await",
        "unwrap"
      ],
      "related_concepts": [],
      "projects": []
    },
    "structured-concurrency": {
      "title": "Structured Concurrency",
      "level": "expert",
      "description": "Structured concurrency ensures that spawned tasks are properly managed and cleaned up.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "structured-concurrency",
      "keywords": [
        "struct"
      ],
      "related_concepts": [],
      "projects": []
    },
    "task-groups": {
      "title": "Task Groups",
      "level": "expert",
      "description": "use tokio::task::JoinSet;",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "task-groups",
      "keywords": [
        "async",
        "await",
        "match",
        "result",
        "struct",
        "unwrap",
        "vec"
      ],
      "related_concepts": [],
      "projects": []
    },
    "avoiding-common-pitfalls": {
      "title": "Avoiding Common Pitfalls",
      "level": "expert",
      "description": "// BAD: Blocking the async runtime",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "avoiding-common-pitfalls",
      "keywords": [
        "async",
        "await",
        "result",
        "string",
        "thread"
      ],
      "related_concepts": [],
      "projects": []
    },
    "buffering-and-batching": {
      "title": "Buffering and Batching",
      "level": "expert",
      "description": "use futures::stream::{self, StreamExt};",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "buffering-and-batching",
      "keywords": [
        "async",
        "await",
        "collect",
        "map",
        "result",
        "vec"
      ],
      "related_concepts": [],
      "projects": []
    },
    "memory-management": {
      "title": "Memory Management",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "memory-management",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "testing-async-code": {
      "title": "Testing Async Code",
      "level": "expert",
      "description": "Testing asynchronous code requires special considerations and tools.",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "testing-async-code",
      "keywords": [
        "async"
      ],
      "related_concepts": [
        "special-considerations-and-tools"
      ],
      "projects": []
    },
    "basic-async-tests": {
      "title": "Basic Async Tests",
      "level": "expert",
      "description": "async fn test_async_function() {",
      "file_path": "expert\\module1\\CONCEPTS.md",
      "section": "basic-async-tests",
      "keywords": [
        "async",
        "await",
        "impl",
        "result"
      ],
      "related_concepts": [],
      "projects": []
    },
    "advanced-ownership-concepts": {
      "title": "Advanced Ownership Concepts",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "advanced-ownership-concepts",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "lifetimes-and-borrowing": {
      "title": "Lifetimes and Borrowing",
      "level": "intermediate",
      "description": "The capstone project demonstrates complex lifetime management in several areas:",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "lifetimes-and-borrowing",
      "keywords": [
        "borrowing",
        "box",
        "impl",
        "lifetime",
        "map",
        "option",
        "reference",
        "struct",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "smart-pointers-and-shared-ownership": {
      "title": "Smart Pointers and Shared Ownership",
      "level": "intermediate",
      "description": "The project extensively uses smart pointers for safe shared ownership:",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "smart-pointers-and-shared-ownership",
      "keywords": [
        "\n- interior mutability with ",
        " and ",
        " vs ",
        "arc",
        "mutex",
        "ownership",
        "rc",
        "refcell",
        "reference",
        "result"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "interior-mutability-patterns": {
      "title": "Interior Mutability Patterns",
      "level": "intermediate",
      "description": "use std::cell::{RefCell, Cell};",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "interior-mutability-patterns",
      "keywords": [
        "\n\n**key learning points**:\n- ",
        "arc",
        "box",
        "map",
        "mutex",
        "rc",
        "refcell",
        "struct",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "traits-and-generics": {
      "title": "Traits and Generics",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "traits-and-generics",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "generic-trait-definitions": {
      "title": "Generic Trait Definitions",
      "level": "intermediate",
      "description": "The task system is built around a generic trait that allows any type to be a task:",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "generic-trait-definitions",
      "keywords": [
        "generic",
        "map",
        "option",
        "result",
        "struct",
        "trait",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "trait-objects-and-dynamic-dispatch": {
      "title": "Trait Objects and Dynamic Dispatch",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "trait-objects-and-dynamic-dispatch",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "advanced-trait-implementations": {
      "title": "Advanced Trait Implementations",
      "level": "intermediate",
      "description": "// Implementing standard library traits",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "advanced-trait-implementations",
      "keywords": [
        "generic",
        "impl",
        "result",
        "struct",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "concurrency-and-collections": {
      "title": "Concurrency and Collections",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "concurrency-and-collections",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "thread-pool-management": {
      "title": "Thread Pool Management",
      "level": "intermediate",
      "description": "pub struct WorkerPool {",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "thread-pool-management",
      "keywords": [
        "box",
        "enum",
        "option",
        "struct",
        "thread",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "channel-communication": {
      "title": "Channel Communication",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "channel-communication",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "thread-synchronization": {
      "title": "Thread Synchronization",
      "level": "intermediate",
      "description": "use std::sync::{Arc, Mutex, Condvar, Barrier};",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "thread-synchronization",
      "keywords": [
        "arc",
        "mutex",
        "rc",
        "struct",
        "thread",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "concurrent-collections": {
      "title": "Concurrent Collections",
      "level": "intermediate",
      "description": "use std::collections::HashMap;",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "concurrent-collections",
      "keywords": [
        "arc",
        "collect",
        "impl",
        "map",
        "mutex",
        "rc",
        "struct",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "error-conversion-and-propagation": {
      "title": "Error Conversion and Propagation",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "error-conversion-and-propagation",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "error-context-and-recovery": {
      "title": "Error Context and Recovery",
      "level": "intermediate",
      "description": "// Adding context to errors",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "error-context-and-recovery",
      "keywords": [
        "impl",
        "map",
        "match",
        "result",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "integration-patterns": {
      "title": "Integration Patterns",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "integration-patterns",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "combining-all-concepts": {
      "title": "Combining All Concepts",
      "level": "intermediate",
      "description": "The capstone project demonstrates how all these concepts work together:",
      "file_path": "intermediate\\capstone-project\\CONCEPTS.md",
      "section": "combining-all-concepts",
      "keywords": [
        "arc",
        "box",
        "generic",
        "impl",
        "map",
        "mutex",
        "ownership",
        "rc",
        "result",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "capstone-project"
      ]
    },
    "concept-overview": {
      "title": "Concept Overview",
      "level": "intermediate",
      "description": "Rust's ecosystem provides many high-quality crates for common tasks. Learning to integrate and use external crates is essential for productive Rust development.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "concept-overview",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "implementation-in-project": {
      "title": "Implementation in Project",
      "level": "intermediate",
      "description": "// Buffered I/O for better performance",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "implementation-in-project",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "key-learning-points": {
      "title": "Key Learning Points",
      "level": "intermediate",
      "description": "- Buffered I/O: Reducing system calls for better performance",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "key-learning-points",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "why-this-matters": {
      "title": "Why This Matters",
      "level": "intermediate",
      "description": "Performance considerations become important as applications scale. Understanding these patterns helps you write efficient code from the start.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "why-this-matters",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "file-io-and-resource-management": {
      "title": "File I/O and Resource Management",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "file-io-and-resource-management",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "json-serialization-with-serde": {
      "title": "JSON Serialization with Serde",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "json-serialization-with-serde",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "command-line-parsing": {
      "title": "Command Line Parsing",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "command-line-parsing",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "testing-patterns": {
      "title": "Testing Patterns",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "testing-patterns",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "module-organization": {
      "title": "Module Organization",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "module-organization",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "advanced-ownership-patterns": {
      "title": "Advanced Ownership Patterns",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "advanced-ownership-patterns",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "error-handling-best-practices": {
      "title": "Error Handling Best Practices",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "error-handling-best-practices",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "recommended-follow-up-projects": {
      "title": "Recommended Follow-up Projects",
      "level": "intermediate",
      "description": "1. Network Database: Add HTTP API support",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "recommended-follow-up-projects",
      "keywords": [
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "additional-resources": {
      "title": "Additional Resources",
      "level": "intermediate",
      "description": "- [Rust Error Handling Book](https://doc.rust-lang.org/book/ch09-00-error-handling.html)",
      "file_path": "intermediate\\cli-database-tool\\CONCEPTS.md",
      "section": "additional-resources",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "cli-database-tool"
      ]
    },
    "what-are-generics": {
      "title": "What are Generics?",
      "level": "intermediate",
      "description": "Generics allow you to write code that works with multiple types while maintaining type safety. Instead of writing separate implementations for each type, you can write one generic implementation.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "what-are-generics",
      "keywords": [
        "generic",
        "impl",
        "string",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "generic-type-parameters": {
      "title": "Generic Type Parameters",
      "level": "intermediate",
      "description": "The <T> syntax introduces a type parameter. T is a placeholder that gets replaced with concrete types when the generic is used:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "generic-type-parameters",
      "keywords": [
        "<t>",
        "generic",
        "string",
        "t",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "generic-methods": {
      "title": "Generic Methods",
      "level": "intermediate",
      "description": "Methods on generic structs can also use the type parameter:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "generic-methods",
      "keywords": [
        "generic",
        "impl",
        "option",
        "reference",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "benefits-of-generics": {
      "title": "Benefits of Generics",
      "level": "intermediate",
      "description": "1. Code Reuse: Write once, use with many types",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "benefits-of-generics",
      "keywords": [
        "expect"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "what-are-traits": {
      "title": "What are Traits?",
      "level": "intermediate",
      "description": "Traits define shared behavior that types can implement. They're similar to interfaces in other languages but more powerful.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "what-are-traits",
      "keywords": [
        "impl",
        "string",
        "trait",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "standard-library-traits": {
      "title": "Standard Library Traits",
      "level": "intermediate",
      "description": "The project implements several important standard library traits:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "standard-library-traits",
      "keywords": [
        "impl",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "index-and-indexmut-traits": {
      "title": "Index and IndexMut Traits",
      "level": "intermediate",
      "description": "Enable array-like access with [] syntax:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "index-and-indexmut-traits",
      "keywords": [
        "[]",
        "expect",
        "impl",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "drop-trait": {
      "title": "Drop Trait",
      "level": "intermediate",
      "description": "Defines cleanup behavior when a value goes out of scope:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "drop-trait",
      "keywords": [
        "impl",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "clone-trait": {
      "title": "Clone Trait",
      "level": "intermediate",
      "description": "Enables creating deep copies:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "clone-trait",
      "keywords": [
        "impl",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "iterator-traits": {
      "title": "Iterator Traits",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "iterator-traits",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "iterator-trait": {
      "title": "Iterator Trait",
      "level": "intermediate",
      "description": "Defines how to iterate over a collection:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "iterator-trait",
      "keywords": [
        "collect",
        "impl",
        "iterator",
        "option",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "intoiterator-trait": {
      "title": "IntoIterator Trait",
      "level": "intermediate",
      "description": "Converts a type into an iterator:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "intoiterator-trait",
      "keywords": [
        "impl",
        "iterator",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "trait-bounds": {
      "title": "Trait Bounds",
      "level": "intermediate",
      "description": "Trait bounds constrain generic types to only those that implement specific traits:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "trait-bounds",
      "keywords": [
        "generic",
        "impl",
        "trait",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "manual-allocation": {
      "title": "Manual Allocation",
      "level": "intermediate",
      "description": "Using std::alloc for memory management:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "manual-allocation",
      "keywords": [
        "expect",
        "std::alloc",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "unsafe-code": {
      "title": "Unsafe Code",
      "level": "intermediate",
      "description": "Raw pointer operations require unsafe blocks:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "unsafe-code",
      "keywords": [
        "reference",
        "unsafe"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "memory-safety-considerations": {
      "title": "Memory Safety Considerations",
      "level": "intermediate",
      "description": "1. Bounds Checking: Always verify indices are within bounds",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "memory-safety-considerations",
      "keywords": [
        "mutable",
        "reference"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "lifetime-parameters": {
      "title": "Lifetime Parameters",
      "level": "intermediate",
      "description": "Lifetimes ensure references remain valid:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "lifetime-parameters",
      "keywords": [
        "impl",
        "iterator",
        "lifetime",
        "option",
        "reference",
        "struct",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "lifetime-elision": {
      "title": "Lifetime Elision",
      "level": "intermediate",
      "description": "In many cases, Rust can infer lifetimes:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "lifetime-elision",
      "keywords": [
        "lifetime",
        "option"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "associated-types": {
      "title": "Associated Types",
      "level": "intermediate",
      "description": "Traits can have associated types that are determined by the implementor:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "associated-types",
      "keywords": [
        "impl",
        "iterator",
        "option",
        "trait",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "operator-overloading": {
      "title": "Operator Overloading",
      "level": "intermediate",
      "description": "Traits enable operator overloading:",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "operator-overloading",
      "keywords": [
        "impl",
        "trait",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "common-patterns": {
      "title": "Common Patterns",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "common-patterns",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "builder-pattern-with-generics": {
      "title": "Builder Pattern with Generics",
      "level": "intermediate",
      "description": "pub fn new() -> Self { / ... / }",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "builder-pattern-with-generics",
      "keywords": [
        "impl",
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "method-chaining": {
      "title": "Method Chaining",
      "level": "intermediate",
      "description": "let vec = MyVec::new()",
      "file_path": "intermediate\\custom-data-structure\\CONCEPTS.md",
      "section": "method-chaining",
      "keywords": [
        "vec"
      ],
      "related_concepts": [],
      "projects": [
        "custom-data-structure"
      ]
    },
    "ownership": {
      "title": "Ownership",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "ownership",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "borrowing": {
      "title": "Borrowing",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\module1\\library-management-system\\CONCEPTS.md",
      "section": "borrowing",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "library-management-system"
      ]
    },
    "threading-and-concurrency": {
      "title": "Threading and Concurrency",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "threading-and-concurrency",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "key-points": {
      "title": "Key Points",
      "level": "intermediate",
      "description": "- Cargo.toml: Dependencies are declared in the project manifest",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "key-points",
      "keywords": [
        "option"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "example-from-project": {
      "title": "Example from Project",
      "level": "intermediate",
      "description": "reqwest = { version = \"0.11\", features = [\"blocking\"] }",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "example-from-project",
      "keywords": [
        " and ",
        "impl",
        "macro",
        "trait"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "learning-exercise": {
      "title": "Learning Exercise",
      "level": "intermediate",
      "description": "Try adding the serde crate to serialize scraping results to JSON. How would you modify the ScrapeResult struct?",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "learning-exercise",
      "keywords": [
        "result",
        "scraperesult",
        "serde",
        "struct"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "shared-ownership-with-arc": {
      "title": "Shared Ownership with Arc",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "shared-ownership-with-arc",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "mutual-exclusion-with-mutex": {
      "title": "Mutual Exclusion with Mutex",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "mutual-exclusion-with-mutex",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "error-handling-in-concurrent-contexts": {
      "title": "Error Handling in Concurrent Contexts",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "error-handling-in-concurrent-contexts",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "external-crate-integration": {
      "title": "External Crate Integration",
      "level": "intermediate",
      "description": "No description available.",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "external-crate-integration",
      "keywords": [],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "thread-pool-pattern": {
      "title": "Thread Pool Pattern",
      "level": "intermediate",
      "description": "The project implements a thread pool pattern, which is a common concurrency design:",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "thread-pool-pattern",
      "keywords": [
        "impl",
        "rc",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "resource-management": {
      "title": "Resource Management",
      "level": "intermediate",
      "description": "The project demonstrates proper resource management in concurrent contexts:",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "resource-management",
      "keywords": [
        "map",
        "rc",
        "result",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    },
    "summary": {
      "title": "Summary",
      "level": "intermediate",
      "description": "This project demonstrates several key Rust concepts working together:",
      "file_path": "intermediate\\multi-threaded-web-scraper\\CONCEPTS.md",
      "section": "summary",
      "keywords": [
        "arc",
        "arc<mutex<t>>",
        "mutable",
        "mutex",
        "ownership",
        "rc",
        "thread"
      ],
      "related_concepts": [],
      "projects": [
        "multi-threaded-web-scraper"
      ]
    }
  },
  "cross_references": {
    "ownership": [
      "table-of-contents",
      "basic-level-conceptsbasic-level-concepts",
      "intermediate-level-conceptsintermediate-level-concepts",
      "ownership-basics",
      "copy-trait",
      "references-and-borrowing",
      "immutable-references",
      "reference-rules",
      "advanced-ownership",
      "lifetime-annotations-in-struct-definitions",
      "lifetime-elision-rules",
      "static-lifetime",
      "generic-enums",
      "the-challenge",
      "safety-considerations",
      "common-pitfalls",
      "safety-invariants",
      "generic-programming",
      "operations-on-raw-pointers",
      "common-invariants",
      "documenting-invariants",
      "further-reading",
      "2-shared-state-with-arc-and-mutex",
      "3-message-passing-with-channels",
      "8-generic-programming",
      "8-ownership-and-borrowing",
      "glossary",
      "string-types",
      "8-resource-management",
      "methods-on-structs",
      "ownership-and-borrowing",
      "option-type",
      "unpin-trait",
      "in-our-code",
      "waker-vtable",
      "lifetime-management",
      "cache-friendly-patterns",
      "techniques",
      "pinning-and-self-referential-structs",
      "lifetimes-and-borrowing",
      "smart-pointers-and-shared-ownership",
      "combining-all-concepts",
      "generic-methods",
      "unsafe-code",
      "memory-safety-considerations",
      "lifetime-parameters",
      "lifetime-elision",
      "summary"
    ],
    "error-handling": [
      "basic-level-conceptsbasic-level-concepts",
      "loops",
      "the-option-enum",
      "matching-with-optiont",
      "resultt-e",
      "shortcuts-for-panic-on-error",
      "propagating-errors",
      "hash-maps",
      "string-handling",
      "lifetimes-in-function-signatures",
      "lifetime-annotations-in-struct-definitions",
      "generic-enums",
      "rust-error-handling",
      "error-propagation",
      "safe-wrapper-pattern",
      "automatic-binding-generation",
      "dynamic-loading",
      "synchronization-primitives",
      "safe-rust-wrappers",
      "ffi-safety-patterns",
      "configuration-dsl",
      "trait-hierarchies",
      "error-recovery",
      "layout-struct",
      "trait-definition",
      "checking-invariants",
      "common-operations",
      "example-simple-configuration-macro",
      "recursive-macros",
      "derive-macros",
      "procedural-macro-errors",
      "macro-composition",
      "2-shared-state-with-arc-and-mutex",
      "5-error-handling-in-concurrent-contexts",
      "6-panic-handling",
      "7-graceful-shutdown",
      "8-generic-programming",
      "testing-concurrent-code",
      "result-type",
      "5-functions-and-methods",
      "1-the-task-struct",
      "methods-on-structs",
      "pattern-matching-with-enums",
      "ownership-and-borrowing",
      "option-type",
      "display-trait",
      "debug-trait",
      "enums-and-pattern-matching",
      "traits-and-trait-implementations",
      "file-io",
      "the-await-keyword",
      "tokio-runtime",
      "runtime-types",
      "task-spawning",
      "async-traits",
      "concurrency",
      "parallelism",
      "error-handling-in-async-code",
      "handling-task-errors",
      "timeout-handling",
      "blocking-operations",
      "connection-pooling",
      "creating-diagnostics",
      "how-it-works",
      "example-optimized-array-addition",
      "rayon-framework",
      "using-perf-with-rust",
      "profiling-in-code",
      "avoiding-compiler-optimizations",
      "future-combinators",
      "async-functions",
      "comparing-runtimes",
      "basic-stream-usage",
      "cancellation-tokens",
      "task-groups",
      "avoiding-common-pitfalls",
      "buffering-and-batching",
      "basic-async-tests",
      "lifetimes-and-borrowing",
      "smart-pointers-and-shared-ownership",
      "generic-trait-definitions",
      "advanced-trait-implementations",
      "thread-pool-management",
      "error-context-and-recovery",
      "combining-all-concepts",
      "generic-methods",
      "benefits-of-generics",
      "index-and-indexmut-traits",
      "iterator-trait",
      "manual-allocation",
      "lifetime-parameters",
      "lifetime-elision",
      "associated-types",
      "key-points",
      "learning-exercise",
      "resource-management"
    ],
    "concurrency": [
      "table-of-contents",
      "advanced-level-conceptsadvanced-level-concepts",
      "expert-level-conceptsexpert-level-concepts",
      "compound-types",
      "propagating-errors",
      "linking-libraries",
      "thread-safety",
      "common-pitfalls",
      "work-stealing-thread-pool",
      "key-components",
      "concepts-demonstrated",
      "synchronization-primitives",
      "safety-invariants",
      "trait-hierarchies",
      "comprehensive-error-types",
      "error-recovery",
      "component-integration",
      "learning-outcomes",
      "why-alignment-matters",
      "safety-requirements",
      "documenting-invariants",
      "atomic-operations",
      "send-and-sync-traits",
      "debugging-unsafe-code",
      "further-reading",
      "1-thread-management",
      "2-shared-state-with-arc-and-mutex",
      "3-message-passing-with-channels",
      "4-raii-resource-acquisition-is-initialization",
      "5-error-handling-in-concurrent-contexts",
      "6-panic-handling",
      "7-graceful-shutdown",
      "8-generic-programming",
      "thread-local-storage",
      "lock-contention",
      "thread-creation-overhead",
      "context-switching",
      "testing-concurrent-code",
      "strategies",
      "how-its-used-in-this-project",
      "related-concepts",
      "what-is-async-programming",
      "the-async-keyword",
      "the-await-keyword",
      "the-runtimes-role",
      "tokio-runtime",
      "what-is-tokio",
      "runtime-types",
      "task-spawning",
      "non-blocking-io",
      "async-traits",
      "concurrency",
      "parallelism",
      "when-to-use-each",
      "error-handling-in-async-code",
      "handling-task-errors",
      "timeout-handling",
      "task-overhead",
      "blocking-operations",
      "connection-pooling",
      "graceful-shutdown",
      "rate-limiting",
      "key-takeaways",
      "key-characteristics",
      "the-polling-model",
      "state-machine-transformation",
      "the-waker-system",
      "our-custom-waker",
      "executor-responsibilities",
      "scheduling-strategies",
      "real-world-executors",
      "cooperative-multitasking",
      "yield-points",
      "lifetime-management",
      "send-and-sync-bounds",
      "cpu-usage",
      "do",
      "dont",
      "parallelization-strategies",
      "work-stealing",
      "optimal-chunk-sizes",
      "memory-prefetching",
      "basic-future-implementation",
      "future-combinators",
      "asyncawait-syntax",
      "async-functions",
      "pinning-and-self-referential-structs",
      "pin-in-async-context",
      "async-runtimes",
      "comparing-runtimes",
      "task-scheduling-and-execution",
      "task-local-storage",
      "async-streams-and-iterators",
      "basic-stream-usage",
      "interval-streams",
      "cancellation-and-timeouts",
      "cancellation-tokens",
      "task-groups",
      "avoiding-common-pitfalls",
      "buffering-and-batching",
      "testing-async-code",
      "basic-async-tests",
      "lifetimes-and-borrowing",
      "smart-pointers-and-shared-ownership",
      "interior-mutability-patterns",
      "thread-pool-management",
      "thread-synchronization",
      "concurrent-collections",
      "error-context-and-recovery",
      "combining-all-concepts",
      "recommended-follow-up-projects",
      "thread-pool-pattern",
      "resource-management",
      "summary"
    ],
    "memory": [
      "table-of-contents",
      "compound-types",
      "unsafe-code-requirements",
      "linking-libraries",
      "automatic-binding-generation",
      "common-pitfalls",
      "key-components",
      "concepts-demonstrated",
      "c-library-functions",
      "safe-rust-wrappers",
      "trait-hierarchies",
      "comprehensive-error-types",
      "error-recovery",
      "component-integration",
      "real-world-applications",
      "learning-outcomes",
      "why-alignment-matters",
      "introduction-to-macros",
      "span-information",
      "1-thread-management",
      "2-shared-state-with-arc-and-mutex",
      "4-raii-resource-acquisition-is-initialization",
      "5-error-handling-in-concurrent-contexts",
      "8-generic-programming",
      "testing-concurrent-code",
      "strategies",
      "how-its-used-in-this-project",
      "related-concepts",
      "glossary",
      "common-string-operations",
      "6-closures",
      "8-resource-management",
      "option-type",
      "async-traits",
      "error-handling-in-async-code",
      "connection-pooling",
      "key-takeaways",
      "compiler-architecture",
      "compilation-stages",
      "abstract-syntax-trees-ast",
      "ast-node-types-in-rust",
      "diagnostic-components",
      "analysis-techniques",
      "unstable-apis-nightly-only",
      "continuous-integration",
      "in-our-code",
      "our-custom-waker",
      "waker-vtable",
      "heap-allocation",
      "memory-prefetching",
      "string-processing-without-allocation",
      "criterionrs-framework",
      "avoiding-compiler-optimizations",
      "measuring-throughput",
      "async-functions",
      "understanding-pin",
      "pin-in-async-context",
      "lifetimes-and-borrowing",
      "smart-pointers-and-shared-ownership",
      "interior-mutability-patterns",
      "thread-pool-management",
      "thread-synchronization",
      "concurrent-collections",
      "combining-all-concepts",
      "thread-pool-pattern",
      "resource-management",
      "summary"
    ],
    "types": [
      "table-of-contents",
      "basic-level-conceptsbasic-level-concepts",
      "intermediate-level-conceptsintermediate-level-concepts",
      "advanced-level-conceptsadvanced-level-concepts",
      "compound-types",
      "control-flow",
      "structs",
      "defining-and-instantiating-structs",
      "tuple-structs",
      "unit-like-structs",
      "methods",
      "enums",
      "defining-enums",
      "the-option-enum",
      "basic-match",
      "patterns-that-bind-to-values",
      "string-slices",
      "lifetime-annotations-in-struct-definitions",
      "lifetime-elision-rules",
      "defining-traits",
      "traits-as-parameters",
      "returning-types-that-implement-traits",
      "generic-functions",
      "generic-structs",
      "generic-enums",
      "3-safe-wrapper-pattern",
      "complex-types",
      "complex-data-structures",
      "best-practices",
      "key-components",
      "synchronization-primitives",
      "trait-hierarchies",
      "generic-programming",
      "comprehensive-error-types",
      "learning-outcomes",
      "key-concepts",
      "when-to-use-unsafe",
      "raw-pointers",
      "layout-struct",
      "the-globalalloc-trait",
      "trait-definition",
      "documenting-invariants",
      "token-types",
      "example-simple-configuration-macro",
      "recursive-macros",
      "types-of-procedural-macros",
      "derive-macros",
      "attribute-macros",
      "parsing-with-syn",
      "code-generation-with-quote",
      "error-handling-in-macros",
      "procedural-macro-errors",
      "span-information",
      "4-raii-resource-acquisition-is-initialization",
      "5-error-handling-in-concurrent-contexts",
      "8-generic-programming",
      "3-structs",
      "7-documentation-comments",
      "how-its-used-in-this-project",
      "related-concepts",
      "string-types",
      "what-are-structs",
      "types-of-structs-in-rust",
      "struct-implementation-in-our-project",
      "1-the-task-struct",
      "2-the-tasklist-struct",
      "methods-on-structs",
      "what-are-enums",
      "basic-enum-usage",
      "enum-implementation-in-our-project",
      "pattern-matching-with-enums",
      "display-trait",
      "debug-trait",
      "enums-and-pattern-matching",
      "traits-and-trait-implementations",
      "file-io",
      "testing",
      "what-is-a-future",
      "connection-pooling",
      "plugin-integration-points",
      "abstract-syntax-trees-ast",
      "ast-node-types-in-rust",
      "creating-diagnostics",
      "types-of-analysis",
      "visitor-pattern",
      "implementation",
      "custom-visitors",
      "state-machine-transformation",
      "why-pin-exists",
      "unpin-trait",
      "our-custom-waker",
      "zero-cost-abstractions",
      "cache-friendly-patterns",
      "structure-of-arrays-vs-array-of-structures",
      "safe-transmutation-with-bytemuck",
      "memory-profiling",
      "the-future-trait",
      "basic-future-implementation",
      "understanding-pin",
      "pin-in-async-context",
      "async-runtimes",
      "basic-stream-usage",
      "structured-concurrency",
      "task-groups",
      "lifetimes-and-borrowing",
      "interior-mutability-patterns",
      "generic-trait-definitions",
      "advanced-trait-implementations",
      "thread-pool-management",
      "thread-synchronization",
      "concurrent-collections",
      "combining-all-concepts",
      "what-are-generics",
      "generic-type-parameters",
      "generic-methods",
      "what-are-traits",
      "standard-library-traits",
      "trait-bounds",
      "lifetime-parameters",
      "associated-types",
      "operator-overloading",
      "example-from-project",
      "learning-exercise"
    ],
    "collections": [
      "basic-level-conceptsbasic-level-concepts",
      "intermediate-level-conceptsintermediate-level-concepts",
      "ownership-basics",
      "vectors",
      "hash-maps",
      "generic-functions",
      "1-rust-allocates-c-uses",
      "safe-wrapper-pattern",
      "best-practices",
      "common-pitfalls",
      "key-components",
      "raw-pointers",
      "code-generation-with-quote",
      "testing-concurrent-code",
      "overview",
      "how-its-used-in-this-project",
      "key-points-to-understand",
      "common-string-operations",
      "4-command-line-argument-parsing",
      "7-iterators",
      "2-the-tasklist-struct",
      "working-with-vectors",
      "debug-trait",
      "testing",
      "task-overhead",
      "connection-pooling",
      "analysis-techniques",
      "custom-visitors",
      "custom-tooling",
      "batching",
      "simd-instruction-sets",
      "implementation-strategies",
      "example-optimized-array-addition",
      "rayon-framework",
      "optimal-chunk-sizes",
      "structure-of-arrays-vs-array-of-structures",
      "string-processing-without-allocation",
      "async-streams-and-iterators",
      "basic-stream-usage",
      "task-groups",
      "buffering-and-batching",
      "generic-trait-definitions",
      "thread-pool-management",
      "thread-synchronization",
      "concurrent-collections",
      "what-are-generics",
      "generic-type-parameters",
      "generic-methods",
      "what-are-traits",
      "index-and-indexmut-traits",
      "drop-trait",
      "clone-trait",
      "iterator-trait",
      "intoiterator-trait",
      "trait-bounds",
      "lifetime-parameters",
      "associated-types",
      "operator-overloading",
      "builder-pattern-with-generics",
      "method-chaining"
    ],
    "functions": [
      "intermediate-level-conceptsintermediate-level-concepts",
      "functions",
      "copy-trait",
      "methods",
      "methods-on-enums",
      "lifetime-annotations-in-struct-definitions",
      "defining-traits",
      "traits-as-parameters",
      "returning-types-that-implement-traits",
      "generic-structs",
      "3-safe-wrapper-pattern",
      "best-practices",
      "conclusion",
      "work-stealing-thread-pool",
      "synchronization-primitives",
      "custom-memory-allocators",
      "bump-allocator",
      "free-list-allocator",
      "generic-programming",
      "error-recovery",
      "next-steps",
      "when-to-use-unsafe",
      "memory-layout-and-alignment",
      "trait-definition",
      "documenting-invariants",
      "send-and-sync-traits",
      "slab-allocator",
      "debugging-unsafe-code",
      "token-types",
      "example-simple-configuration-macro",
      "types-of-procedural-macros",
      "derive-macros",
      "code-generation-with-quote",
      "error-handling-in-macros",
      "macro-composition",
      "conditional-compilation",
      "macro-testing",
      "1-thread-management",
      "2-shared-state-with-arc-and-mutex",
      "3-message-passing-with-channels",
      "4-raii-resource-acquisition-is-initialization",
      "5-error-handling-in-concurrent-contexts",
      "6-panic-handling",
      "7-graceful-shutdown",
      "8-generic-programming",
      "work-stealing-extension",
      "lock-free-programming",
      "lock-contention",
      "5-functions-and-methods",
      "how-its-used-in-this-project",
      "6-closures",
      "types-of-structs-in-rust",
      "methods-on-structs",
      "pattern-matching-with-enums",
      "ownership-and-borrowing",
      "display-trait",
      "debug-trait",
      "traits-and-trait-implementations",
      "the-runtimes-role",
      "timeout-handling",
      "task-overhead",
      "connection-pooling",
      "key-takeaways",
      "traversing-asts",
      "creating-diagnostics",
      "custom-visitors",
      "example-from-our-code",
      "unpin-trait",
      "our-custom-waker",
      "scheduling-strategies",
      "do",
      "memory-profiling",
      "basic-future-implementation",
      "understanding-pin",
      "pin-in-async-context",
      "basic-stream-usage",
      "basic-async-tests",
      "lifetimes-and-borrowing",
      "advanced-trait-implementations",
      "concurrent-collections",
      "error-context-and-recovery",
      "combining-all-concepts",
      "what-are-generics",
      "generic-methods",
      "what-are-traits",
      "standard-library-traits",
      "index-and-indexmut-traits",
      "drop-trait",
      "clone-trait",
      "iterator-trait",
      "intoiterator-trait",
      "trait-bounds",
      "lifetime-parameters",
      "associated-types",
      "operator-overloading",
      "builder-pattern-with-generics",
      "example-from-project",
      "thread-pool-pattern"
    ],
    "testing": [
      "testing-strategies",
      "macro-testing",
      "testing-concurrent-code",
      "testing",
      "performance-regression-testing",
      "testing-async-code",
      "testing-patterns"
    ],
    "advanced": [
      "propagating-errors",
      "string-handling",
      "foreign-function-interface-ffi",
      "what-is-ffi",
      "why-use-ffi",
      "basic-ffi-declaration",
      "c-abi-compatibility",
      "application-binary-interface-abi",
      "c-calling-convention",
      "data-layout-compatibility",
      "memory-management-across-language-boundaries",
      "the-challenge",
      "memory-allocation-patterns",
      "1-rust-allocates-c-uses",
      "2-c-allocates-rust-uses",
      "3-safe-wrapper-pattern",
      "type-conversion-between-rust-and-c",
      "pointer-types",
      "array-handling",
      "complex-types",
      "error-handling-in-ffi",
      "c-error-conventions",
      "rust-error-handling",
      "safety-considerations",
      "unsafe-code-requirements",
      "safety-guidelines",
      "safe-wrapper-pattern",
      "build-system-integration",
      "using-cc-crate",
      "linking-libraries",
      "build-dependencies",
      "automatic-binding-generation",
      "advanced-ffi-patterns",
      "callbacks",
      "complex-data-structures",
      "thread-safety",
      "dynamic-loading",
      "conclusion",
      "concurrency-and-thread-management",
      "work-stealing-thread-pool",
      "key-components",
      "concepts-demonstrated",
      "synchronization-primitives",
      "unsafe-rust-and-memory-management",
      "custom-memory-allocators",
      "bump-allocator",
      "free-list-allocator",
      "safety-invariants",
      "c-library-integration",
      "c-library-functions",
      "safe-rust-wrappers",
      "ffi-safety-patterns",
      "macros-and-domain-specific-languages",
      "declarative-macros",
      "configuration-dsl",
      "advanced-traits-and-type-system",
      "trait-hierarchies",
      "generic-programming",
      "comprehensive-error-types",
      "error-recovery",
      "integration-and-architecture",
      "component-integration",
      "real-world-applications",
      "learning-outcomes",
      "unsafe-rust",
      "key-concepts",
      "when-to-use-unsafe",
      "types-of-raw-pointers",
      "operations-on-raw-pointers",
      "memory-layout-and-alignment",
      "alignment-requirements",
      "layout-struct",
      "alignment-calculations",
      "why-alignment-matters",
      "the-globalalloc-trait",
      "trait-definition",
      "implementation-requirements",
      "safety-requirements",
      "memory-safety-invariants",
      "common-invariants",
      "documenting-invariants",
      "checking-invariants",
      "atomic-operations",
      "atomic-types",
      "memory-ordering",
      "common-operations",
      "send-and-sync-traits",
      "thread-safety-considerations",
      "memory-management-strategies",
      "pool-allocator",
      "slab-allocator",
      "safety-first",
      "debugging-unsafe-code",
      "introduction-to-macros",
      "why-use-macros",
      "types-of-macros",
      "basic-syntax",
      "token-types",
      "example-simple-configuration-macro",
      "recursive-macros",
      "procedural-macros",
      "types-of-procedural-macros",
      "setting-up-procedural-macros",
      "derive-macros",
      "attribute-macros",
      "function-like-macros",
      "token-streams-and-parsing",
      "token-streams",
      "parsing-with-syn",
      "code-generation-with-quote",
      "macro-hygiene",
      "hygienic-macros",
      "example-of-hygiene",
      "breaking-hygiene",
      "error-handling-in-macros",
      "compile-time-errors",
      "procedural-macro-errors",
      "span-information",
      "advanced-techniques",
      "macro-composition",
      "conditional-compilation",
      "macro-testing",
      "core-concepts",
      "1-thread-management",
      "2-shared-state-with-arc-and-mutex",
      "3-message-passing-with-channels",
      "4-raii-resource-acquisition-is-initialization",
      "5-error-handling-in-concurrent-contexts",
      "6-panic-handling",
      "7-graceful-shutdown",
      "8-generic-programming",
      "work-stealing-extension",
      "lock-free-programming",
      "thread-local-storage",
      "lock-contention",
      "thread-creation-overhead",
      "context-switching",
      "challenges",
      "strategies",
      "asyncawait-fundamentals",
      "what-is-async-programming",
      "the-async-keyword",
      "the-await-keyword",
      "futures-and-the-runtime",
      "what-is-a-future",
      "future-states",
      "the-runtimes-role",
      "tokio-runtime",
      "what-is-tokio",
      "runtime-types",
      "task-spawning",
      "async-io-operations",
      "non-blocking-io",
      "async-traits",
      "concurrency-vs-parallelism",
      "concurrency",
      "parallelism",
      "when-to-use-each",
      "error-handling-in-async-code",
      "handling-task-errors",
      "timeout-handling",
      "memory-usage",
      "task-overhead",
      "blocking-operations",
      "common-patterns-and-best-practices",
      "connection-pooling",
      "graceful-shutdown",
      "rate-limiting",
      "key-takeaways",
      "compiler-architecture",
      "compilation-stages",
      "plugin-integration-points",
      "abstract-syntax-trees-ast",
      "ast-node-types-in-rust",
      "traversing-asts",
      "working-with-token-streams",
      "diagnostic-system",
      "diagnostic-components",
      "creating-diagnostics",
      "static-analysis",
      "types-of-analysis",
      "analysis-techniques",
      "visitor-pattern",
      "implementation",
      "custom-visitors",
      "compiler-apis",
      "stable-apis",
      "unstable-apis-nightly-only",
      "using-stable-apis",
      "hygiene",
      "integration-with-development-tools",
      "ide-support",
      "continuous-integration",
      "custom-tooling",
      "futures-and-the-future-trait",
      "key-characteristics",
      "example-from-our-code",
      "polling-and-state-machines",
      "the-polling-model",
      "state-machine-transformation",
      "benefits",
      "pin-and-unpin",
      "why-pin-exists",
      "pint",
      "unpin-trait",
      "in-our-code",
      "wakers-and-context",
      "the-waker-system",
      "context",
      "our-custom-waker",
      "waker-vtable",
      "executors-and-task-scheduling",
      "executor-responsibilities",
      "our-simple-executor",
      "scheduling-strategies",
      "real-world-executors",
      "cooperative-vs-preemptive-multitasking",
      "cooperative-multitasking",
      "drawbacks",
      "yield-points",
      "memory-management-in-async-code",
      "heap-allocation",
      "lifetime-management",
      "send-and-sync-bounds",
      "polling-overhead",
      "batching",
      "io-integration",
      "cpu-usage",
      "do",
      "dont",
      "memory-mapped-files",
      "concept",
      "how-it-works",
      "when-to-use",
      "trade-offs",
      "simd-operations",
      "simd-instruction-sets",
      "implementation-strategies",
      "example-optimized-array-addition",
      "parallel-processing",
      "rayon-framework",
      "parallelization-strategies",
      "work-stealing",
      "optimal-chunk-sizes",
      "cache-optimization",
      "cpu-cache-hierarchy",
      "cache-friendly-patterns",
      "structure-of-arrays-vs-array-of-structures",
      "memory-prefetching",
      "zero-copy-operations",
      "techniques",
      "safe-transmutation-with-bytemuck",
      "string-processing-without-allocation",
      "performance-profiling",
      "profiling-tools",
      "using-perf-with-rust",
      "profiling-in-code",
      "memory-profiling",
      "benchmarking-methodology",
      "statistical-significance",
      "criterionrs-framework",
      "avoiding-compiler-optimizations",
      "measuring-throughput",
      "performance-regression-testing",
      "best-practices-summary",
      "the-future-trait",
      "basic-future-implementation",
      "future-combinators",
      "asyncawait-syntax",
      "async-functions",
      "pinning-and-self-referential-structs",
      "understanding-pin",
      "pin-in-async-context",
      "async-runtimes",
      "comparing-runtimes",
      "task-scheduling-and-execution",
      "task-local-storage",
      "async-streams-and-iterators",
      "basic-stream-usage",
      "interval-streams",
      "cancellation-and-timeouts",
      "cancellation-tokens",
      "structured-concurrency",
      "task-groups",
      "avoiding-common-pitfalls",
      "buffering-and-batching",
      "testing-async-code",
      "basic-async-tests"
    ]
  },
  "learning_path": {
    "basic": [
      "1-string-manipulation",
      "1-the-task-struct",
      "1-variables-and-data-types",
      "2-enums-and-pattern-matching",
      "2-file-io",
      "2-the-tasklist-struct",
      "3-error-handling",
      "3-structs",
      "4-command-line-argument-parsing",
      "4-error-handling",
      "5-functions-and-methods",
      "5-traits-and-generics",
      "6-closures",
      "6-string-manipulation",
      "7-documentation-comments",
      "7-iterators",
      "8-ownership-and-borrowing",
      "8-resource-management",
      "9-standard-library-usage",
      "advanced-level-conceptsadvanced-level-concepts",
      "advanced-ownership",
      "basic-enum-usage",
      "basic-function-definition",
      "basic-level-concepts",
      "basic-level-conceptsbasic-level-concepts",
      "basic-match",
      "basic-syntax-and-control-flow",
      "catch-all-patterns",
      "command-parsing",
      "common-string-operations",
      "compound-types",
      "constants",
      "control-flow",
      "copy-trait",
      "creating-strings",
      "data-types",
      "defining-and-instantiating-structs",
      "defining-enums",
      "defining-traits",
      "display-trait",
      "enum-implementation-in-our-project",
      "enums",
      "enums-and-pattern-matching",
      "enums-in-rust",
      "error-handling-with-result-and-option",
      "error-propagation",
      "expert-level-conceptsexpert-level-concepts",
      "external-crates-and-dependencies",
      "file-io",
      "file-system-operations",
      "functions",
      "functions-with-return-values",
      "generic-enums",
      "generic-structs",
      "hash-maps",
      "if-expressions",
      "if-let",
      "immutable-references",
      "immutable-variables",
      "intermediate-level-concepts",
      "intermediate-level-conceptsintermediate-level-concepts",
      "iterating-over-strings",
      "lifetime-annotations-in-struct-definitions",
      "lifetime-elision-rules",
      "lifetimes-in-function-signatures",
      "loops",
      "matching-with-optiont",
      "methods",
      "methods-on-enums",
      "methods-on-structs",
      "move-semantics",
      "mutable-references",
      "mutable-variables",
      "option-type",
      "ownership-and-borrowing",
      "ownership-basics",
      "ownership-concepts-in-the-project",
      "ownership-rules",
      "path-manipulation",
      "pattern-matching",
      "pattern-matching-with-enums",
      "patterns-that-bind-to-values",
      "primitive-types",
      "reading-files",
      "reference-rules",
      "references-and-borrowing",
      "result-type",
      "resultt-e",
      "returning-types-that-implement-traits",
      "scalar-types",
      "shadowing",
      "shortcuts-for-panic-on-error",
      "statements-vs-expressions",
      "static-lifetime",
      "string-slices",
      "string-types",
      "struct-implementation-in-our-project",
      "structs",
      "structs-in-rust",
      "testing",
      "the-option-enum",
      "traits-and-trait-implementations",
      "traits-as-parameters",
      "tuple-structs",
      "types-of-structs-in-rust",
      "unit-like-structs",
      "updating-strings",
      "user-input-and-output",
      "variables",
      "variables-and-mutability",
      "vectors",
      "what-are-enums",
      "what-are-structs",
      "working-with-vectors",
      "writing-files"
    ],
    "intermediate": [
      "additional-resources",
      "advanced-concepts",
      "advanced-ownership-concepts",
      "advanced-ownership-patterns",
      "advanced-trait-implementations",
      "associated-types",
      "benefits-of-generics",
      "best-practices",
      "borrowing",
      "builder-pattern-with-generics",
      "channel-communication",
      "clone-trait",
      "collections",
      "combining-all-concepts",
      "command-line-parsing",
      "common-patterns",
      "common-pitfalls",
      "concept-overview",
      "concurrency-and-collections",
      "concurrent-collections",
      "custom-error-types",
      "debug-trait",
      "drop-trait",
      "error-context-and-recovery",
      "error-conversion-and-propagation",
      "error-handling",
      "error-handling-best-practices",
      "error-handling-in-concurrent-contexts",
      "error-handling-patterns",
      "example-from-project",
      "external-crate-integration",
      "file-io-and-resource-management",
      "further-reading",
      "generic-functions",
      "generic-methods",
      "generic-trait-definitions",
      "generic-type-parameters",
      "generics",
      "glossary",
      "how-its-used-in-this-project",
      "implementation-in-project",
      "index-and-indexmut-traits",
      "integration-patterns",
      "interior-mutability-patterns",
      "intoiterator-trait",
      "iterator-trait",
      "iterator-traits",
      "json-serialization-with-serde",
      "key-learning-points",
      "key-points",
      "key-points-to-understand",
      "learning-exercise",
      "lifetime-elision",
      "lifetime-parameters",
      "lifetimes",
      "lifetimes-and-borrowing",
      "manual-allocation",
      "memory-management",
      "memory-safety-considerations",
      "method-chaining",
      "module-organization",
      "mutual-exclusion-with-mutex",
      "next-steps",
      "operator-overloading",
      "overview",
      "ownership",
      "performance-considerations",
      "raw-pointers",
      "recommended-follow-up-projects",
      "related-concepts",
      "resource-management",
      "shared-ownership-with-arc",
      "smart-pointers-and-shared-ownership",
      "standard-library-traits",
      "structs-and-methods",
      "summary",
      "table-of-contents",
      "testing-concurrent-code",
      "testing-patterns",
      "testing-strategies",
      "thread-pool-management",
      "thread-pool-pattern",
      "thread-synchronization",
      "threading-and-concurrency",
      "trait-bounds",
      "trait-objects-and-dynamic-dispatch",
      "traits",
      "traits-and-generics",
      "unsafe-code",
      "what-are-generics",
      "what-are-traits",
      "why-this-matters",
      "zero-cost-abstractions"
    ],
    "advanced": [
      "1-rust-allocates-c-uses",
      "1-thread-management",
      "2-c-allocates-rust-uses",
      "2-shared-state-with-arc-and-mutex",
      "3-message-passing-with-channels",
      "3-safe-wrapper-pattern",
      "4-raii-resource-acquisition-is-initialization",
      "5-error-handling-in-concurrent-contexts",
      "6-panic-handling",
      "7-graceful-shutdown",
      "8-generic-programming",
      "advanced-ffi-patterns",
      "advanced-techniques",
      "advanced-traits-and-type-system",
      "alignment-calculations",
      "alignment-requirements",
      "application-binary-interface-abi",
      "array-handling",
      "atomic-operations",
      "atomic-types",
      "attribute-macros",
      "automatic-binding-generation",
      "basic-ffi-declaration",
      "basic-syntax",
      "breaking-hygiene",
      "build-dependencies",
      "build-system-integration",
      "bump-allocator",
      "c-abi-compatibility",
      "c-calling-convention",
      "c-error-conventions",
      "c-library-functions",
      "c-library-integration",
      "callbacks",
      "challenges",
      "checking-invariants",
      "code-generation-with-quote",
      "common-invariants",
      "common-operations",
      "compile-time-errors",
      "complex-data-structures",
      "complex-types",
      "component-integration",
      "comprehensive-error-types",
      "concepts-demonstrated",
      "concurrency-and-thread-management",
      "conditional-compilation",
      "configuration-dsl",
      "context-switching",
      "core-concepts",
      "custom-memory-allocators",
      "data-layout-compatibility",
      "debugging-unsafe-code",
      "declarative-macros",
      "derive-macros",
      "documenting-invariants",
      "dynamic-loading",
      "error-handling-in-ffi",
      "example-of-hygiene",
      "example-simple-configuration-macro",
      "ffi-safety-patterns",
      "foreign-function-interface-ffi",
      "free-list-allocator",
      "function-like-macros",
      "generic-programming",
      "hygienic-macros",
      "implementation-requirements",
      "integration-and-architecture",
      "introduction-to-macros",
      "key-components",
      "layout-struct",
      "learning-outcomes",
      "linking-libraries",
      "lock-contention",
      "lock-free-programming",
      "macro-composition",
      "macro-hygiene",
      "macro-testing",
      "macros-and-domain-specific-languages",
      "memory-allocation-patterns",
      "memory-layout-and-alignment",
      "memory-management-across-language-boundaries",
      "memory-management-strategies",
      "memory-ordering",
      "memory-safety-invariants",
      "operations-on-raw-pointers",
      "parsing-with-syn",
      "pointer-types",
      "pool-allocator",
      "procedural-macro-errors",
      "real-world-applications",
      "recursive-macros",
      "rust-error-handling",
      "safe-rust-wrappers",
      "safe-wrapper-pattern",
      "safety-considerations",
      "safety-first",
      "safety-guidelines",
      "safety-invariants",
      "safety-requirements",
      "send-and-sync-traits",
      "setting-up-procedural-macros",
      "slab-allocator",
      "strategies",
      "string-handling",
      "synchronization-primitives",
      "the-challenge",
      "the-globalalloc-trait",
      "thread-creation-overhead",
      "thread-local-storage",
      "thread-safety",
      "thread-safety-considerations",
      "token-streams-and-parsing",
      "trait-definition",
      "trait-hierarchies",
      "type-conversion-between-rust-and-c",
      "types-of-macros",
      "types-of-raw-pointers",
      "unsafe-code-requirements",
      "unsafe-rust",
      "unsafe-rust-and-memory-management",
      "using-cc-crate",
      "what-is-ffi",
      "when-to-use-unsafe",
      "why-alignment-matters",
      "why-use-ffi",
      "why-use-macros",
      "work-stealing-extension",
      "work-stealing-thread-pool"
    ],
    "expert": [
      "abstract-syntax-trees-ast",
      "analysis-techniques",
      "ast-node-types-in-rust",
      "async-functions",
      "async-io-operations",
      "async-runtimes",
      "async-streams-and-iterators",
      "async-traits",
      "asyncawait-fundamentals",
      "asyncawait-syntax",
      "avoiding-common-pitfalls",
      "avoiding-compiler-optimizations",
      "basic-async-tests",
      "basic-future-implementation",
      "basic-stream-usage",
      "batching",
      "benchmarking-methodology",
      "benefits",
      "best-practices-summary",
      "blocking-operations",
      "buffering-and-batching",
      "cache-friendly-patterns",
      "cache-optimization",
      "cancellation-and-timeouts",
      "cancellation-tokens",
      "common-patterns-and-best-practices",
      "comparing-runtimes",
      "compilation-stages",
      "compiler-apis",
      "compiler-architecture",
      "concept",
      "conclusion",
      "concurrency",
      "concurrency-vs-parallelism",
      "connection-pooling",
      "context",
      "continuous-integration",
      "cooperative-multitasking",
      "cooperative-vs-preemptive-multitasking",
      "cpu-cache-hierarchy",
      "cpu-usage",
      "creating-diagnostics",
      "criterionrs-framework",
      "custom-tooling",
      "custom-visitors",
      "diagnostic-components",
      "diagnostic-system",
      "do",
      "dont",
      "drawbacks",
      "error-handling-in-async-code",
      "error-handling-in-macros",
      "error-recovery",
      "example-from-our-code",
      "example-optimized-array-addition",
      "executor-responsibilities",
      "executors-and-task-scheduling",
      "future-combinators",
      "future-states",
      "futures-and-the-future-trait",
      "futures-and-the-runtime",
      "graceful-shutdown",
      "handling-task-errors",
      "heap-allocation",
      "how-it-works",
      "hygiene",
      "ide-support",
      "implementation",
      "implementation-strategies",
      "in-our-code",
      "integration-with-development-tools",
      "interval-streams",
      "io-integration",
      "key-characteristics",
      "key-concepts",
      "key-takeaways",
      "lifetime-management",
      "measuring-throughput",
      "memory-management-in-async-code",
      "memory-mapped-files",
      "memory-prefetching",
      "memory-profiling",
      "memory-usage",
      "non-blocking-io",
      "optimal-chunk-sizes",
      "our-custom-waker",
      "our-simple-executor",
      "parallel-processing",
      "parallelism",
      "parallelization-strategies",
      "performance-profiling",
      "performance-regression-testing",
      "pin-and-unpin",
      "pin-in-async-context",
      "pinning-and-self-referential-structs",
      "pint",
      "plugin-integration-points",
      "polling-and-state-machines",
      "polling-overhead",
      "procedural-macros",
      "profiling-in-code",
      "profiling-tools",
      "propagating-errors",
      "rate-limiting",
      "rayon-framework",
      "real-world-executors",
      "runtime-types",
      "safe-transmutation-with-bytemuck",
      "scheduling-strategies",
      "send-and-sync-bounds",
      "simd-instruction-sets",
      "simd-operations",
      "span-information",
      "stable-apis",
      "state-machine-transformation",
      "static-analysis",
      "statistical-significance",
      "string-processing-without-allocation",
      "structure-of-arrays-vs-array-of-structures",
      "structured-concurrency",
      "task-groups",
      "task-local-storage",
      "task-overhead",
      "task-scheduling-and-execution",
      "task-spawning",
      "techniques",
      "testing-async-code",
      "the-async-keyword",
      "the-await-keyword",
      "the-future-trait",
      "the-polling-model",
      "the-runtimes-role",
      "the-waker-system",
      "timeout-handling",
      "token-streams",
      "token-types",
      "tokio-runtime",
      "trade-offs",
      "traversing-asts",
      "types-of-analysis",
      "types-of-procedural-macros",
      "understanding-pin",
      "unpin-trait",
      "unstable-apis-nightly-only",
      "using-perf-with-rust",
      "using-stable-apis",
      "visitor-pattern",
      "waker-vtable",
      "wakers-and-context",
      "what-is-a-future",
      "what-is-async-programming",
      "what-is-tokio",
      "when-to-use",
      "when-to-use-each",
      "why-pin-exists",
      "work-stealing",
      "working-with-token-streams",
      "yield-points",
      "zero-copy-operations"
    ]
  },
  "metadata": {
    "total_concepts": 496,
    "files_processed": 22,
    "last_updated": "2025-07-20T12:29:24.829998"
  }
}